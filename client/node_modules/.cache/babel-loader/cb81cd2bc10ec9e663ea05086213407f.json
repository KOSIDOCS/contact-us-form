{"ast":null,"code":"'use strict'; // Load modules\n\nconst Punycode = require('punycode');\n\nconst Util = require('util'); // Declare internals\n\n\nconst internals = {\n  hasOwn: Object.prototype.hasOwnProperty,\n  indexOf: Array.prototype.indexOf,\n  defaultThreshold: 16,\n  maxIPv6Groups: 8,\n  categories: {\n    valid: 1,\n    dnsWarn: 7,\n    rfc5321: 15,\n    cfws: 31,\n    deprecated: 63,\n    rfc5322: 127,\n    error: 255\n  },\n  diagnoses: {\n    // Address is valid\n    valid: 0,\n    // Address is valid for SMTP but has unusual elements\n    rfc5321TLD: 9,\n    rfc5321TLDNumeric: 10,\n    rfc5321QuotedString: 11,\n    rfc5321AddressLiteral: 12,\n    // Address is valid for message, but must be modified for envelope\n    cfwsComment: 17,\n    cfwsFWS: 18,\n    // Address contains non-ASCII when the allowUnicode option is false\n    // Has to be > internals.defaultThreshold so that it's rejected\n    // without an explicit errorLevel:\n    undesiredNonAscii: 25,\n    // Address contains deprecated elements, but may still be valid in some contexts\n    deprecatedLocalPart: 33,\n    deprecatedFWS: 34,\n    deprecatedQTEXT: 35,\n    deprecatedQP: 36,\n    deprecatedComment: 37,\n    deprecatedCTEXT: 38,\n    deprecatedIPv6: 39,\n    deprecatedCFWSNearAt: 49,\n    // Address is only valid according to broad definition in RFC 5322, but is otherwise invalid\n    rfc5322Domain: 65,\n    rfc5322TooLong: 66,\n    rfc5322LocalTooLong: 67,\n    rfc5322DomainTooLong: 68,\n    rfc5322LabelTooLong: 69,\n    rfc5322DomainLiteral: 70,\n    rfc5322DomainLiteralOBSDText: 71,\n    rfc5322IPv6GroupCount: 72,\n    rfc5322IPv62x2xColon: 73,\n    rfc5322IPv6BadCharacter: 74,\n    rfc5322IPv6MaxGroups: 75,\n    rfc5322IPv6ColonStart: 76,\n    rfc5322IPv6ColonEnd: 77,\n    // Address is invalid for any purpose\n    errExpectingDTEXT: 129,\n    errNoLocalPart: 130,\n    errNoDomain: 131,\n    errConsecutiveDots: 132,\n    errATEXTAfterCFWS: 133,\n    errATEXTAfterQS: 134,\n    errATEXTAfterDomainLiteral: 135,\n    errExpectingQPair: 136,\n    errExpectingATEXT: 137,\n    errExpectingQTEXT: 138,\n    errExpectingCTEXT: 139,\n    errBackslashEnd: 140,\n    errDotStart: 141,\n    errDotEnd: 142,\n    errDomainHyphenStart: 143,\n    errDomainHyphenEnd: 144,\n    errUnclosedQuotedString: 145,\n    errUnclosedComment: 146,\n    errUnclosedDomainLiteral: 147,\n    errFWSCRLFx2: 148,\n    errFWSCRLFEnd: 149,\n    errCRNoLF: 150,\n    errUnknownTLD: 160,\n    errDomainTooShort: 161,\n    errDotAfterDomainLiteral: 162\n  },\n  components: {\n    localpart: 0,\n    domain: 1,\n    literal: 2,\n    contextComment: 3,\n    contextFWS: 4,\n    contextQuotedString: 5,\n    contextQuotedPair: 6\n  }\n};\n\ninternals.specials = function () {\n  const specials = '()<>[]:;@\\\\,.\"'; // US-ASCII visible characters not valid for atext (http://tools.ietf.org/html/rfc5322#section-3.2.3)\n\n  const lookup = new Array(0x100);\n  lookup.fill(false);\n\n  for (let i = 0; i < specials.length; ++i) {\n    lookup[specials.codePointAt(i)] = true;\n  }\n\n  return function (code) {\n    return lookup[code];\n  };\n}();\n\ninternals.c0Controls = function () {\n  const lookup = new Array(0x100);\n  lookup.fill(false); // add C0 control characters\n\n  for (let i = 0; i < 33; ++i) {\n    lookup[i] = true;\n  }\n\n  return function (code) {\n    return lookup[code];\n  };\n}();\n\ninternals.c1Controls = function () {\n  const lookup = new Array(0x100);\n  lookup.fill(false); // add C1 control characters\n\n  for (let i = 127; i < 160; ++i) {\n    lookup[i] = true;\n  }\n\n  return function (code) {\n    return lookup[code];\n  };\n}();\n\ninternals.regex = {\n  ipV4: /\\b(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  ipV6: /^[a-fA-F\\d]{0,4}$/\n};\ninternals.normalizeSupportsNul = '\\0'.normalize('NFC') === '\\0'; // $lab:coverage:off$\n\ninternals.nulNormalize = function (email) {\n  return email.split('\\0').map(part => part.normalize('NFC')).join('\\0');\n}; // $lab:coverage:on$\n\n\ninternals.normalize = function (email) {\n  return email.normalize('NFC');\n}; // $lab:coverage:off$\n\n\nif (!internals.normalizeSupportsNul) {\n  internals.normalize = function (email) {\n    if (email.indexOf('\\0') >= 0) {\n      return internals.nulNormalize(email);\n    }\n\n    return email.normalize('NFC');\n  };\n} // $lab:coverage:on$\n\n\ninternals.checkIpV6 = function (items) {\n  return items.every(value => internals.regex.ipV6.test(value));\n};\n\ninternals.isIterable = Array.isArray;\n/* $lab:coverage:off$ */\n\nif (typeof Symbol !== 'undefined') {\n  internals.isIterable = value => Array.isArray(value) || !!value && typeof value === 'object' && typeof value[Symbol.iterator] === 'function';\n}\n/* $lab:coverage:on$ */\n// Node 10 introduced isSet and isMap, which are useful for cross-context type\n// checking.\n// $lab:coverage:off$\n\n\ninternals._isSet = value => value instanceof Set;\n\ninternals._isMap = value => value instanceof Map;\n\ninternals.isSet = Util.types && Util.types.isSet || internals._isSet;\ninternals.isMap = Util.types && Util.types.isMap || internals._isMap; // $lab:coverage:on$\n\n/**\n * Normalize the given lookup \"table\" to an iterator. Outputs items in arrays\n * and sets, keys from maps (regardless of the corresponding value), and own\n * enumerable keys from all other objects (intended to be plain objects).\n *\n * @param {*} table The table to convert.\n * @returns {Iterable<*>} The converted table.\n */\n\ninternals.normalizeTable = function (table) {\n  if (internals.isSet(table) || Array.isArray(table)) {\n    return table;\n  }\n\n  if (internals.isMap(table)) {\n    return table.keys();\n  }\n\n  return Object.keys(table);\n};\n/**\n * Convert the given domain atom to its canonical form using Nameprep and string\n * lowercasing. Domain atoms that are all-ASCII will not undergo any changes via\n * Nameprep, and domain atoms that have already been canonicalized will not be\n * altered.\n *\n * @param {string} atom The atom to canonicalize.\n * @returns {string} The canonicalized atom.\n */\n\n\ninternals.canonicalizeAtom = function (atom) {\n  return Punycode.toASCII(atom).toLowerCase();\n};\n/**\n * Check whether any of the values in the given iterable, when passed through\n * the iteratee function, are equal to the given value.\n *\n * @param {Iterable<*>} iterable The iterable to check.\n * @param {function(*): *} iteratee The iteratee that receives each item from\n *   the iterable.\n * @param {*} value The reference value.\n * @returns {boolean} Whether the given value matches any of the items in the\n *   iterable per the iteratee.\n */\n\n\ninternals.includesMapped = function (iterable, iteratee, value) {\n  for (const item of iterable) {\n    if (value === iteratee(item)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Check whether the given top-level domain atom is valid based on the\n * configured blacklist/whitelist.\n *\n * @param {string} tldAtom The atom to check.\n * @param {Object} options\n *   {*} tldBlacklist The set of domains to consider invalid.\n *   {*} tldWhitelist The set of domains to consider valid.\n * @returns {boolean} Whether the given domain atom is valid per the blacklist/\n *   whitelist.\n */\n\n\ninternals.validDomain = function (tldAtom, options) {\n  // Nameprep handles case-sensitive unicode stuff, but doesn't touch\n  // uppercase ASCII characters.\n  const canonicalTldAtom = internals.canonicalizeAtom(tldAtom);\n\n  if (options.tldBlacklist) {\n    return !internals.includesMapped(internals.normalizeTable(options.tldBlacklist), internals.canonicalizeAtom, canonicalTldAtom);\n  }\n\n  return internals.includesMapped(internals.normalizeTable(options.tldWhitelist), internals.canonicalizeAtom, canonicalTldAtom);\n};\n/**\n * Check whether the domain atoms has an address literal part followed by a\n * normal domain atom part. For example, [127.0.0.1].com.\n *\n * @param {string[]} domainAtoms The parsed domain atoms.\n * @returns {boolean} Whether there exists both a normal domain atom and an\n *   address literal.\n */\n\n\ninternals.hasDomainLiteralThenAtom = function (domainAtoms) {\n  let hasDomainLiteral = false;\n\n  for (let i = 0; i < domainAtoms.length; ++i) {\n    if (domainAtoms[i][0] === '[') {\n      hasDomainLiteral = true;\n    } else if (hasDomainLiteral) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Check that an email address conforms to RFCs 5321, 5322, 6530 and others\n *\n * We distinguish clearly between a Mailbox as defined by RFC 5321 and an\n * addr-spec as defined by RFC 5322. Depending on the context, either can be\n * regarded as a valid email address. The RFC 5321 Mailbox specification is\n * more restrictive (comments, white space and obsolete forms are not allowed).\n *\n * @param {string} email The email address to check. See README for specifics.\n * @param {Object} options The (optional) options:\n *   {*} errorLevel Determines the boundary between valid and invalid\n *     addresses.\n *   {*} tldBlacklist The set of domains to consider invalid.\n *   {*} tldWhitelist The set of domains to consider valid.\n *   {*} allowUnicode Whether to allow non-ASCII characters, defaults to true.\n *   {*} minDomainAtoms The minimum number of domain atoms which must be present\n *     for the address to be valid.\n * @param {function(number|boolean)} callback The (optional) callback handler.\n * @return {*}\n */\n\n\nexports.validate = internals.validate = function (email, options, callback) {\n  options = options || {};\n\n  if (typeof email !== 'string') {\n    throw new TypeError('expected string email');\n  }\n\n  email = internals.normalize(email); // The callback function is deprecated.\n  // $lab:coverage:off$\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  if (typeof callback !== 'function') {\n    callback = null;\n  } // $lab:coverage:on$\n\n\n  let diagnose;\n  let threshold;\n\n  if (typeof options.errorLevel === 'number') {\n    diagnose = true;\n    threshold = options.errorLevel;\n  } else {\n    diagnose = !!options.errorLevel;\n    threshold = internals.diagnoses.valid;\n  }\n\n  if (options.tldWhitelist) {\n    if (typeof options.tldWhitelist === 'string') {\n      options.tldWhitelist = [options.tldWhitelist];\n    } else if (typeof options.tldWhitelist !== 'object') {\n      throw new TypeError('expected array or object tldWhitelist');\n    }\n  }\n\n  if (options.tldBlacklist) {\n    if (typeof options.tldBlacklist === 'string') {\n      options.tldBlacklist = [options.tldBlacklist];\n    } else if (typeof options.tldBlacklist !== 'object') {\n      throw new TypeError('expected array or object tldBlacklist');\n    }\n  }\n\n  if (options.minDomainAtoms && (options.minDomainAtoms !== (+options.minDomainAtoms | 0) || options.minDomainAtoms < 0)) {\n    throw new TypeError('expected positive integer minDomainAtoms');\n  } // Normalize the set of excluded diagnoses.\n\n\n  if (options.excludeDiagnoses) {\n    if (!internals.isIterable(options.excludeDiagnoses)) {\n      throw new TypeError('expected iterable excludeDiagnoses');\n    } // This won't catch cross-realm Sets pre-Node 10, but it will cast the\n    // value to an in-realm Set representation.\n\n\n    if (!internals.isSet(options.excludeDiagnoses)) {\n      options.excludeDiagnoses = new Set(options.excludeDiagnoses);\n    }\n  }\n\n  let maxResult = internals.diagnoses.valid;\n\n  const updateResult = value => {\n    if (value > maxResult && (!options.excludeDiagnoses || !options.excludeDiagnoses.has(value))) {\n      maxResult = value;\n    }\n  };\n\n  const allowUnicode = options.allowUnicode === undefined || !!options.allowUnicode;\n\n  if (!allowUnicode && /[^\\x00-\\x7f]/.test(email)) {\n    updateResult(internals.diagnoses.undesiredNonAscii);\n  }\n\n  const context = {\n    now: internals.components.localpart,\n    prev: internals.components.localpart,\n    stack: [internals.components.localpart]\n  };\n  let prevToken = '';\n  const parseData = {\n    local: '',\n    domain: ''\n  };\n  const atomData = {\n    locals: [''],\n    domains: ['']\n  };\n  let elementCount = 0;\n  let elementLength = 0;\n  let crlfCount = 0;\n  let charCode;\n  let hyphenFlag = false;\n  let assertEnd = false;\n  const emailLength = email.length;\n  let token; // Token is used outside the loop, must declare similarly\n\n  for (let i = 0; i < emailLength; i += token.length) {\n    // Utilize codepoints to account for Unicode surrogate pairs\n    token = String.fromCodePoint(email.codePointAt(i));\n\n    switch (context.now) {\n      // Local-part\n      case internals.components.localpart:\n        // http://tools.ietf.org/html/rfc5322#section-3.4.1\n        //   local-part      =   dot-atom / quoted-string / obs-local-part\n        //\n        //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\n        //\n        //   dot-atom-text   =   1*atext *(\".\" 1*atext)\n        //\n        //   quoted-string   =   [CFWS]\n        //                       DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n        //                       [CFWS]\n        //\n        //   obs-local-part  =   word *(\".\" word)\n        //\n        //   word            =   atom / quoted-string\n        //\n        //   atom            =   [CFWS] 1*atext [CFWS]\n        switch (token) {\n          // Comment\n          case '(':\n            if (elementLength === 0) {\n              // Comments are OK at the beginning of an element\n              updateResult(elementCount === 0 ? internals.diagnoses.cfwsComment : internals.diagnoses.deprecatedComment);\n            } else {\n              updateResult(internals.diagnoses.cfwsComment); // Cannot start a comment in an element, should be end\n\n              assertEnd = true;\n            }\n\n            context.stack.push(context.now);\n            context.now = internals.components.contextComment;\n            break;\n          // Next dot-atom element\n\n          case '.':\n            if (elementLength === 0) {\n              // Another dot, already?\n              updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\n            } else {\n              // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\n              if (assertEnd) {\n                updateResult(internals.diagnoses.deprecatedLocalPart);\n              } // CFWS & quoted strings are OK again now we're at the beginning of an element (although they are obsolete forms)\n\n\n              assertEnd = false;\n              elementLength = 0;\n              ++elementCount;\n              parseData.local += token;\n              atomData.locals[elementCount] = '';\n            }\n\n            break;\n          // Quoted string\n\n          case '\"':\n            if (elementLength === 0) {\n              // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\n              updateResult(elementCount === 0 ? internals.diagnoses.rfc5321QuotedString : internals.diagnoses.deprecatedLocalPart);\n              parseData.local += token;\n              atomData.locals[elementCount] += token;\n              elementLength += Buffer.byteLength(token, 'utf8'); // Quoted string must be the entire element\n\n              assertEnd = true;\n              context.stack.push(context.now);\n              context.now = internals.components.contextQuotedString;\n            } else {\n              updateResult(internals.diagnoses.errExpectingATEXT);\n            }\n\n            break;\n          // Folding white space\n\n          case '\\r':\n            if (emailLength === ++i || email[i] !== '\\n') {\n              // Fatal error\n              updateResult(internals.diagnoses.errCRNoLF);\n              break;\n            }\n\n          // Fallthrough\n\n          case ' ':\n          case '\\t':\n            if (elementLength === 0) {\n              updateResult(elementCount === 0 ? internals.diagnoses.cfwsFWS : internals.diagnoses.deprecatedFWS);\n            } else {\n              // We can't start FWS in the middle of an element, better be end\n              assertEnd = true;\n            }\n\n            context.stack.push(context.now);\n            context.now = internals.components.contextFWS;\n            prevToken = token;\n            break;\n\n          case '@':\n            // At this point we should have a valid local-part\n            // $lab:coverage:off$\n            if (context.stack.length !== 1) {\n              throw new Error('unexpected item on context stack');\n            } // $lab:coverage:on$\n\n\n            if (parseData.local.length === 0) {\n              // Fatal error\n              updateResult(internals.diagnoses.errNoLocalPart);\n            } else if (elementLength === 0) {\n              // Fatal error\n              updateResult(internals.diagnoses.errDotEnd);\n            } // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1 the maximum total length of a user name or other local-part is 64\n            //    octets\n            else if (Buffer.byteLength(parseData.local, 'utf8') > 64) {\n                updateResult(internals.diagnoses.rfc5322LocalTooLong);\n              } // http://tools.ietf.org/html/rfc5322#section-3.4.1 comments and folding white space SHOULD NOT be used around \"@\" in the\n              //    addr-spec\n              //\n              // http://tools.ietf.org/html/rfc2119\n              // 4. SHOULD NOT this phrase, or the phrase \"NOT RECOMMENDED\" mean that there may exist valid reasons in particular\n              //    circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood\n              //    and the case carefully weighed before implementing any behavior described with this label.\n              else if (context.prev === internals.components.contextComment || context.prev === internals.components.contextFWS) {\n                  updateResult(internals.diagnoses.deprecatedCFWSNearAt);\n                } // Clear everything down for the domain parsing\n\n\n            context.now = internals.components.domain;\n            context.stack[0] = internals.components.domain;\n            elementCount = 0;\n            elementLength = 0;\n            assertEnd = false; // CFWS can only appear at the end of the element\n\n            break;\n          // ATEXT\n\n          default:\n            // http://tools.ietf.org/html/rfc5322#section-3.2.3\n            //    atext = ALPHA / DIGIT / ; Printable US-ASCII\n            //            \"!\" / \"#\" /     ;  characters not including\n            //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\n            //            \"&\" / \"'\" /\n            //            \"*\" / \"+\" /\n            //            \"-\" / \"/\" /\n            //            \"=\" / \"?\" /\n            //            \"^\" / \"_\" /\n            //            \"`\" / \"{\" /\n            //            \"|\" / \"}\" /\n            //            \"~\"\n            if (assertEnd) {\n              // We have encountered atext where it is no longer valid\n              switch (context.prev) {\n                case internals.components.contextComment:\n                case internals.components.contextFWS:\n                  updateResult(internals.diagnoses.errATEXTAfterCFWS);\n                  break;\n\n                case internals.components.contextQuotedString:\n                  updateResult(internals.diagnoses.errATEXTAfterQS);\n                  break;\n                // $lab:coverage:off$\n\n                default:\n                  throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\n                // $lab:coverage:on$\n              }\n            } else {\n              context.prev = context.now;\n              charCode = token.codePointAt(0); // Especially if charCode == 10\n\n              if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {\n                // Fatal error\n                updateResult(internals.diagnoses.errExpectingATEXT);\n              }\n\n              parseData.local += token;\n              atomData.locals[elementCount] += token;\n              elementLength += Buffer.byteLength(token, 'utf8');\n            }\n\n        }\n\n        break;\n\n      case internals.components.domain:\n        // http://tools.ietf.org/html/rfc5322#section-3.4.1\n        //   domain          =   dot-atom / domain-literal / obs-domain\n        //\n        //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\n        //\n        //   dot-atom-text   =   1*atext *(\".\" 1*atext)\n        //\n        //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\n        //\n        //   dtext           =   %d33-90 /          ; Printable US-ASCII\n        //                       %d94-126 /         ;  characters not including\n        //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\n        //\n        //   obs-domain      =   atom *(\".\" atom)\n        //\n        //   atom            =   [CFWS] 1*atext [CFWS]\n        // http://tools.ietf.org/html/rfc5321#section-4.1.2\n        //   Mailbox        = Local-part \"@\" ( Domain / address-literal )\n        //\n        //   Domain         = sub-domain *(\".\" sub-domain)\n        //\n        //   address-literal  = \"[\" ( IPv4-address-literal /\n        //                    IPv6-address-literal /\n        //                    General-address-literal ) \"]\"\n        //                    ; See Section 4.1.3\n        // http://tools.ietf.org/html/rfc5322#section-3.4.1\n        //      Note: A liberal syntax for the domain portion of addr-spec is\n        //      given here.  However, the domain portion contains addressing\n        //      information specified by and used in other protocols (e.g.,\n        //      [RFC1034], [RFC1035], [RFC1123], [RFC5321]).  It is therefore\n        //      incumbent upon implementations to conform to the syntax of\n        //      addresses for the context in which they are used.\n        //\n        // is_email() author's note: it's not clear how to interpret this in\n        // he context of a general email address validator. The conclusion I\n        // have reached is this: \"addressing information\" must comply with\n        // RFC 5321 (and in turn RFC 1035), anything that is \"semantically\n        // invisible\" must comply only with RFC 5322.\n        switch (token) {\n          // Comment\n          case '(':\n            if (elementLength === 0) {\n              // Comments at the start of the domain are deprecated in the text, comments at the start of a subdomain are obs-domain\n              // http://tools.ietf.org/html/rfc5322#section-3.4.1\n              updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedComment);\n            } else {\n              // We can't start a comment mid-element, better be at the end\n              assertEnd = true;\n              updateResult(internals.diagnoses.cfwsComment);\n            }\n\n            context.stack.push(context.now);\n            context.now = internals.components.contextComment;\n            break;\n          // Next dot-atom element\n\n          case '.':\n            const punycodeLength = Punycode.toASCII(atomData.domains[elementCount]).length;\n\n            if (elementLength === 0) {\n              // Another dot, already? Fatal error.\n              updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\n            } else if (hyphenFlag) {\n              // Previous subdomain ended in a hyphen. Fatal error.\n              updateResult(internals.diagnoses.errDomainHyphenEnd);\n            } else if (punycodeLength > 63) {\n              // RFC 5890 specifies that domain labels that are encoded using the Punycode algorithm\n              // must adhere to the <= 63 octet requirement.\n              // This includes string prefixes from the Punycode algorithm.\n              //\n              // https://tools.ietf.org/html/rfc5890#section-2.3.2.1\n              // labels          63 octets or less\n              updateResult(internals.diagnoses.rfc5322LabelTooLong);\n            } // CFWS is OK again now we're at the beginning of an element (although\n            // it may be obsolete CFWS)\n\n\n            assertEnd = false;\n            elementLength = 0;\n            ++elementCount;\n            atomData.domains[elementCount] = '';\n            parseData.domain += token;\n            break;\n          // Domain literal\n\n          case '[':\n            if (atomData.domains[elementCount].length === 0) {\n              if (parseData.domain.length) {\n                // Domain literal interspersed with domain refs.\n                updateResult(internals.diagnoses.errDotAfterDomainLiteral);\n              }\n\n              assertEnd = true;\n              elementLength += Buffer.byteLength(token, 'utf8');\n              context.stack.push(context.now);\n              context.now = internals.components.literal;\n              parseData.domain += token;\n              atomData.domains[elementCount] += token;\n              parseData.literal = '';\n            } else {\n              // Fatal error\n              updateResult(internals.diagnoses.errExpectingATEXT);\n            }\n\n            break;\n          // Folding white space\n\n          case '\\r':\n            if (emailLength === ++i || email[i] !== '\\n') {\n              // Fatal error\n              updateResult(internals.diagnoses.errCRNoLF);\n              break;\n            }\n\n          // Fallthrough\n\n          case ' ':\n          case '\\t':\n            if (elementLength === 0) {\n              updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedFWS);\n            } else {\n              // We can't start FWS in the middle of an element, so this better be the end\n              updateResult(internals.diagnoses.cfwsFWS);\n              assertEnd = true;\n            }\n\n            context.stack.push(context.now);\n            context.now = internals.components.contextFWS;\n            prevToken = token;\n            break;\n          // This must be ATEXT\n\n          default:\n            // RFC 5322 allows any atext...\n            // http://tools.ietf.org/html/rfc5322#section-3.2.3\n            //    atext = ALPHA / DIGIT / ; Printable US-ASCII\n            //            \"!\" / \"#\" /     ;  characters not including\n            //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\n            //            \"&\" / \"'\" /\n            //            \"*\" / \"+\" /\n            //            \"-\" / \"/\" /\n            //            \"=\" / \"?\" /\n            //            \"^\" / \"_\" /\n            //            \"`\" / \"{\" /\n            //            \"|\" / \"}\" /\n            //            \"~\"\n            // But RFC 5321 only allows letter-digit-hyphen to comply with DNS rules\n            //   (RFCs 1034 & 1123)\n            // http://tools.ietf.org/html/rfc5321#section-4.1.2\n            //   sub-domain     = Let-dig [Ldh-str]\n            //\n            //   Let-dig        = ALPHA / DIGIT\n            //\n            //   Ldh-str        = *( ALPHA / DIGIT / \"-\" ) Let-dig\n            //\n            if (assertEnd) {\n              // We have encountered ATEXT where it is no longer valid\n              switch (context.prev) {\n                case internals.components.contextComment:\n                case internals.components.contextFWS:\n                  updateResult(internals.diagnoses.errATEXTAfterCFWS);\n                  break;\n\n                case internals.components.literal:\n                  updateResult(internals.diagnoses.errATEXTAfterDomainLiteral);\n                  break;\n                // $lab:coverage:off$\n\n                default:\n                  throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\n                // $lab:coverage:on$\n              }\n            }\n\n            charCode = token.codePointAt(0); // Assume this token isn't a hyphen unless we discover it is\n\n            hyphenFlag = false;\n\n            if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {\n              // Fatal error\n              updateResult(internals.diagnoses.errExpectingATEXT);\n            } else if (token === '-') {\n              if (elementLength === 0) {\n                // Hyphens cannot be at the beginning of a subdomain, fatal error\n                updateResult(internals.diagnoses.errDomainHyphenStart);\n              }\n\n              hyphenFlag = true;\n            } // Check if it's a neither a number nor a latin/unicode letter\n            else if (charCode < 48 || charCode > 122 && charCode < 192 || charCode > 57 && charCode < 65 || charCode > 90 && charCode < 97) {\n                // This is not an RFC 5321 subdomain, but still OK by RFC 5322\n                updateResult(internals.diagnoses.rfc5322Domain);\n              }\n\n            parseData.domain += token;\n            atomData.domains[elementCount] += token;\n            elementLength += Buffer.byteLength(token, 'utf8');\n        }\n\n        break;\n      // Domain literal\n\n      case internals.components.literal:\n        // http://tools.ietf.org/html/rfc5322#section-3.4.1\n        //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\n        //\n        //   dtext           =   %d33-90 /          ; Printable US-ASCII\n        //                       %d94-126 /         ;  characters not including\n        //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\n        //\n        //   obs-dtext       =   obs-NO-WS-CTL / quoted-pair\n        switch (token) {\n          // End of domain literal\n          case ']':\n            if (maxResult < internals.categories.deprecated) {\n              // Could be a valid RFC 5321 address literal, so let's check\n              // http://tools.ietf.org/html/rfc5321#section-4.1.2\n              //   address-literal  = \"[\" ( IPv4-address-literal /\n              //                    IPv6-address-literal /\n              //                    General-address-literal ) \"]\"\n              //                    ; See Section 4.1.3\n              //\n              // http://tools.ietf.org/html/rfc5321#section-4.1.3\n              //   IPv4-address-literal  = Snum 3(\".\"  Snum)\n              //\n              //   IPv6-address-literal  = \"IPv6:\" IPv6-addr\n              //\n              //   General-address-literal  = Standardized-tag \":\" 1*dcontent\n              //\n              //   Standardized-tag  = Ldh-str\n              //                     ; Standardized-tag MUST be specified in a\n              //                     ; Standards-Track RFC and registered with IANA\n              //\n              //   dcontent      = %d33-90 / ; Printable US-ASCII\n              //                 %d94-126 ; excl. \"[\", \"\\\", \"]\"\n              //\n              //   Snum          = 1*3DIGIT\n              //                 ; representing a decimal integer\n              //                 ; value in the range 0 through 255\n              //\n              //   IPv6-addr     = IPv6-full / IPv6-comp / IPv6v4-full / IPv6v4-comp\n              //\n              //   IPv6-hex      = 1*4HEXDIG\n              //\n              //   IPv6-full     = IPv6-hex 7(\":\" IPv6-hex)\n              //\n              //   IPv6-comp     = [IPv6-hex *5(\":\" IPv6-hex)] \"::\"\n              //                 [IPv6-hex *5(\":\" IPv6-hex)]\n              //                 ; The \"::\" represents at least 2 16-bit groups of\n              //                 ; zeros.  No more than 6 groups in addition to the\n              //                 ; \"::\" may be present.\n              //\n              //   IPv6v4-full   = IPv6-hex 5(\":\" IPv6-hex) \":\" IPv4-address-literal\n              //\n              //   IPv6v4-comp   = [IPv6-hex *3(\":\" IPv6-hex)] \"::\"\n              //                 [IPv6-hex *3(\":\" IPv6-hex) \":\"]\n              //                 IPv4-address-literal\n              //                 ; The \"::\" represents at least 2 16-bit groups of\n              //                 ; zeros.  No more than 4 groups in addition to the\n              //                 ; \"::\" and IPv4-address-literal may be present.\n              let index = -1;\n              let addressLiteral = parseData.literal;\n              const matchesIP = internals.regex.ipV4.exec(addressLiteral); // Maybe extract IPv4 part from the end of the address-literal\n\n              if (matchesIP) {\n                index = matchesIP.index;\n\n                if (index !== 0) {\n                  // Convert IPv4 part to IPv6 format for futher testing\n                  addressLiteral = addressLiteral.slice(0, index) + '0:0';\n                }\n              }\n\n              if (index === 0) {\n                // Nothing there except a valid IPv4 address, so...\n                updateResult(internals.diagnoses.rfc5321AddressLiteral);\n              } else if (addressLiteral.slice(0, 5).toLowerCase() !== 'ipv6:') {\n                updateResult(internals.diagnoses.rfc5322DomainLiteral);\n              } else {\n                const match = addressLiteral.slice(5);\n                let maxGroups = internals.maxIPv6Groups;\n                const groups = match.split(':');\n                index = match.indexOf('::');\n\n                if (!~index) {\n                  // Need exactly the right number of groups\n                  if (groups.length !== maxGroups) {\n                    updateResult(internals.diagnoses.rfc5322IPv6GroupCount);\n                  }\n                } else if (index !== match.lastIndexOf('::')) {\n                  updateResult(internals.diagnoses.rfc5322IPv62x2xColon);\n                } else {\n                  if (index === 0 || index === match.length - 2) {\n                    // RFC 4291 allows :: at the start or end of an address with 7 other groups in addition\n                    ++maxGroups;\n                  }\n\n                  if (groups.length > maxGroups) {\n                    updateResult(internals.diagnoses.rfc5322IPv6MaxGroups);\n                  } else if (groups.length === maxGroups) {\n                    // Eliding a single \"::\"\n                    updateResult(internals.diagnoses.deprecatedIPv6);\n                  }\n                } // IPv6 testing strategy\n\n\n                if (match[0] === ':' && match[1] !== ':') {\n                  updateResult(internals.diagnoses.rfc5322IPv6ColonStart);\n                } else if (match[match.length - 1] === ':' && match[match.length - 2] !== ':') {\n                  updateResult(internals.diagnoses.rfc5322IPv6ColonEnd);\n                } else if (internals.checkIpV6(groups)) {\n                  updateResult(internals.diagnoses.rfc5321AddressLiteral);\n                } else {\n                  updateResult(internals.diagnoses.rfc5322IPv6BadCharacter);\n                }\n              }\n            } else {\n              updateResult(internals.diagnoses.rfc5322DomainLiteral);\n            }\n\n            parseData.domain += token;\n            atomData.domains[elementCount] += token;\n            elementLength += Buffer.byteLength(token, 'utf8');\n            context.prev = context.now;\n            context.now = context.stack.pop();\n            break;\n\n          case '\\\\':\n            updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\n            context.stack.push(context.now);\n            context.now = internals.components.contextQuotedPair;\n            break;\n          // Folding white space\n\n          case '\\r':\n            if (emailLength === ++i || email[i] !== '\\n') {\n              updateResult(internals.diagnoses.errCRNoLF);\n              break;\n            }\n\n          // Fallthrough\n\n          case ' ':\n          case '\\t':\n            updateResult(internals.diagnoses.cfwsFWS);\n            context.stack.push(context.now);\n            context.now = internals.components.contextFWS;\n            prevToken = token;\n            break;\n          // DTEXT\n\n          default:\n            // http://tools.ietf.org/html/rfc5322#section-3.4.1\n            //   dtext         =   %d33-90 /  ; Printable US-ASCII\n            //                     %d94-126 / ;  characters not including\n            //                     obs-dtext  ;  \"[\", \"]\", or \"\\\"\n            //\n            //   obs-dtext     =   obs-NO-WS-CTL / quoted-pair\n            //\n            //   obs-NO-WS-CTL =   %d1-8 /    ; US-ASCII control\n            //                     %d11 /     ;  characters that do not\n            //                     %d12 /     ;  include the carriage\n            //                     %d14-31 /  ;  return, line feed, and\n            //                     %d127      ;  white space characters\n            charCode = token.codePointAt(0); // '\\r', '\\n', ' ', and '\\t' have already been parsed above\n\n            if (charCode !== 127 && internals.c1Controls(charCode) || charCode === 0 || token === '[') {\n              // Fatal error\n              updateResult(internals.diagnoses.errExpectingDTEXT);\n              break;\n            } else if (internals.c0Controls(charCode) || charCode === 127) {\n              updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\n            }\n\n            parseData.literal += token;\n            parseData.domain += token;\n            atomData.domains[elementCount] += token;\n            elementLength += Buffer.byteLength(token, 'utf8');\n        }\n\n        break;\n      // Quoted string\n\n      case internals.components.contextQuotedString:\n        // http://tools.ietf.org/html/rfc5322#section-3.2.4\n        //   quoted-string = [CFWS]\n        //                   DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n        //                   [CFWS]\n        //\n        //   qcontent      = qtext / quoted-pair\n        switch (token) {\n          // Quoted pair\n          case '\\\\':\n            context.stack.push(context.now);\n            context.now = internals.components.contextQuotedPair;\n            break;\n          // Folding white space. Spaces are allowed as regular characters inside a quoted string - it's only FWS if we include '\\t' or '\\r\\n'\n\n          case '\\r':\n            if (emailLength === ++i || email[i] !== '\\n') {\n              // Fatal error\n              updateResult(internals.diagnoses.errCRNoLF);\n              break;\n            }\n\n          // Fallthrough\n\n          case '\\t':\n            // http://tools.ietf.org/html/rfc5322#section-3.2.2\n            //   Runs of FWS, comment, or CFWS that occur between lexical tokens in\n            //   a structured header field are semantically interpreted as a single\n            //   space character.\n            // http://tools.ietf.org/html/rfc5322#section-3.2.4\n            //   the CRLF in any FWS/CFWS that appears within the quoted-string [is]\n            //   semantically \"invisible\" and therefore not part of the\n            //   quoted-string\n            parseData.local += ' ';\n            atomData.locals[elementCount] += ' ';\n            elementLength += Buffer.byteLength(token, 'utf8');\n            updateResult(internals.diagnoses.cfwsFWS);\n            context.stack.push(context.now);\n            context.now = internals.components.contextFWS;\n            prevToken = token;\n            break;\n          // End of quoted string\n\n          case '\"':\n            parseData.local += token;\n            atomData.locals[elementCount] += token;\n            elementLength += Buffer.byteLength(token, 'utf8');\n            context.prev = context.now;\n            context.now = context.stack.pop();\n            break;\n          // QTEXT\n\n          default:\n            // http://tools.ietf.org/html/rfc5322#section-3.2.4\n            //   qtext          =   %d33 /             ; Printable US-ASCII\n            //                      %d35-91 /          ;  characters not including\n            //                      %d93-126 /         ;  \"\\\" or the quote character\n            //                      obs-qtext\n            //\n            //   obs-qtext      =   obs-NO-WS-CTL\n            //\n            //   obs-NO-WS-CTL  =   %d1-8 /            ; US-ASCII control\n            //                      %d11 /             ;  characters that do not\n            //                      %d12 /             ;  include the carriage\n            //                      %d14-31 /          ;  return, line feed, and\n            //                      %d127              ;  white space characters\n            charCode = token.codePointAt(0);\n\n            if (charCode !== 127 && internals.c1Controls(charCode) || charCode === 0 || charCode === 10) {\n              updateResult(internals.diagnoses.errExpectingQTEXT);\n            } else if (internals.c0Controls(charCode) || charCode === 127) {\n              updateResult(internals.diagnoses.deprecatedQTEXT);\n            }\n\n            parseData.local += token;\n            atomData.locals[elementCount] += token;\n            elementLength += Buffer.byteLength(token, 'utf8');\n        } // http://tools.ietf.org/html/rfc5322#section-3.4.1\n        //   If the string can be represented as a dot-atom (that is, it contains\n        //   no characters other than atext characters or \".\" surrounded by atext\n        //   characters), then the dot-atom form SHOULD be used and the quoted-\n        //   string form SHOULD NOT be used.\n\n\n        break;\n      // Quoted pair\n\n      case internals.components.contextQuotedPair:\n        // http://tools.ietf.org/html/rfc5322#section-3.2.1\n        //   quoted-pair     =   (\"\\\" (VCHAR / WSP)) / obs-qp\n        //\n        //   VCHAR           =  %d33-126   ; visible (printing) characters\n        //   WSP             =  SP / HTAB  ; white space\n        //\n        //   obs-qp          =   \"\\\" (%d0 / obs-NO-WS-CTL / LF / CR)\n        //\n        //   obs-NO-WS-CTL   =   %d1-8 /   ; US-ASCII control\n        //                       %d11 /    ;  characters that do not\n        //                       %d12 /    ;  include the carriage\n        //                       %d14-31 / ;  return, line feed, and\n        //                       %d127     ;  white space characters\n        //\n        // i.e. obs-qp       =  \"\\\" (%d0-8, %d10-31 / %d127)\n        charCode = token.codePointAt(0);\n\n        if (charCode !== 127 && internals.c1Controls(charCode)) {\n          // Fatal error\n          updateResult(internals.diagnoses.errExpectingQPair);\n        } else if (charCode < 31 && charCode !== 9 || charCode === 127) {\n          // ' ' and '\\t' are allowed\n          updateResult(internals.diagnoses.deprecatedQP);\n        } // At this point we know where this qpair occurred so we could check to see if the character actually needed to be quoted at all.\n        // http://tools.ietf.org/html/rfc5321#section-4.1.2\n        //   the sending system SHOULD transmit the form that uses the minimum quoting possible.\n\n\n        context.prev = context.now; // End of qpair\n\n        context.now = context.stack.pop();\n        const escapeToken = '\\\\' + token;\n\n        switch (context.now) {\n          case internals.components.contextComment:\n            break;\n\n          case internals.components.contextQuotedString:\n            parseData.local += escapeToken;\n            atomData.locals[elementCount] += escapeToken; // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\n\n            elementLength += 2;\n            break;\n\n          case internals.components.literal:\n            parseData.domain += escapeToken;\n            atomData.domains[elementCount] += escapeToken; // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\n\n            elementLength += 2;\n            break;\n          // $lab:coverage:off$\n\n          default:\n            throw new Error('quoted pair logic invoked in an invalid context: ' + context.now);\n          // $lab:coverage:on$\n        }\n\n        break;\n      // Comment\n\n      case internals.components.contextComment:\n        // http://tools.ietf.org/html/rfc5322#section-3.2.2\n        //   comment  = \"(\" *([FWS] ccontent) [FWS] \")\"\n        //\n        //   ccontent = ctext / quoted-pair / comment\n        switch (token) {\n          // Nested comment\n          case '(':\n            // Nested comments are ok\n            context.stack.push(context.now);\n            context.now = internals.components.contextComment;\n            break;\n          // End of comment\n\n          case ')':\n            context.prev = context.now;\n            context.now = context.stack.pop();\n            break;\n          // Quoted pair\n\n          case '\\\\':\n            context.stack.push(context.now);\n            context.now = internals.components.contextQuotedPair;\n            break;\n          // Folding white space\n\n          case '\\r':\n            if (emailLength === ++i || email[i] !== '\\n') {\n              // Fatal error\n              updateResult(internals.diagnoses.errCRNoLF);\n              break;\n            }\n\n          // Fallthrough\n\n          case ' ':\n          case '\\t':\n            updateResult(internals.diagnoses.cfwsFWS);\n            context.stack.push(context.now);\n            context.now = internals.components.contextFWS;\n            prevToken = token;\n            break;\n          // CTEXT\n\n          default:\n            // http://tools.ietf.org/html/rfc5322#section-3.2.3\n            //   ctext         = %d33-39 /  ; Printable US-ASCII\n            //                   %d42-91 /  ;  characters not including\n            //                   %d93-126 / ;  \"(\", \")\", or \"\\\"\n            //                   obs-ctext\n            //\n            //   obs-ctext     = obs-NO-WS-CTL\n            //\n            //   obs-NO-WS-CTL = %d1-8 /    ; US-ASCII control\n            //                   %d11 /     ;  characters that do not\n            //                   %d12 /     ;  include the carriage\n            //                   %d14-31 /  ;  return, line feed, and\n            //                   %d127      ;  white space characters\n            charCode = token.codePointAt(0);\n\n            if (charCode === 0 || charCode === 10 || charCode !== 127 && internals.c1Controls(charCode)) {\n              // Fatal error\n              updateResult(internals.diagnoses.errExpectingCTEXT);\n              break;\n            } else if (internals.c0Controls(charCode) || charCode === 127) {\n              updateResult(internals.diagnoses.deprecatedCTEXT);\n            }\n\n        }\n\n        break;\n      // Folding white space\n\n      case internals.components.contextFWS:\n        // http://tools.ietf.org/html/rfc5322#section-3.2.2\n        //   FWS     =   ([*WSP CRLF] 1*WSP) /  obs-FWS\n        //                                   ; Folding white space\n        // But note the erratum:\n        // http://www.rfc-editor.org/errata_search.php?rfc=5322&eid=1908:\n        //   In the obsolete syntax, any amount of folding white space MAY be\n        //   inserted where the obs-FWS rule is allowed.  This creates the\n        //   possibility of having two consecutive \"folds\" in a line, and\n        //   therefore the possibility that a line which makes up a folded header\n        //   field could be composed entirely of white space.\n        //\n        //   obs-FWS =   1*([CRLF] WSP)\n        if (prevToken === '\\r') {\n          if (token === '\\r') {\n            // Fatal error\n            updateResult(internals.diagnoses.errFWSCRLFx2);\n            break;\n          }\n\n          if (++crlfCount > 1) {\n            // Multiple folds => obsolete FWS\n            updateResult(internals.diagnoses.deprecatedFWS);\n          } else {\n            crlfCount = 1;\n          }\n        }\n\n        switch (token) {\n          case '\\r':\n            if (emailLength === ++i || email[i] !== '\\n') {\n              // Fatal error\n              updateResult(internals.diagnoses.errCRNoLF);\n            }\n\n            break;\n\n          case ' ':\n          case '\\t':\n            break;\n\n          default:\n            if (prevToken === '\\r') {\n              // Fatal error\n              updateResult(internals.diagnoses.errFWSCRLFEnd);\n            }\n\n            crlfCount = 0; // End of FWS\n\n            context.prev = context.now;\n            context.now = context.stack.pop(); // Look at this token again in the parent context\n\n            --i;\n        }\n\n        prevToken = token;\n        break;\n      // Unexpected context\n      // $lab:coverage:off$\n\n      default:\n        throw new Error('unknown context: ' + context.now);\n      // $lab:coverage:on$\n    } // Primary state machine\n\n\n    if (maxResult > internals.categories.rfc5322) {\n      // Fatal error, no point continuing\n      break;\n    }\n  } // Token loop\n  // Check for errors\n\n\n  if (maxResult < internals.categories.rfc5322) {\n    const punycodeLength = Punycode.toASCII(parseData.domain).length; // Fatal errors\n\n    if (context.now === internals.components.contextQuotedString) {\n      updateResult(internals.diagnoses.errUnclosedQuotedString);\n    } else if (context.now === internals.components.contextQuotedPair) {\n      updateResult(internals.diagnoses.errBackslashEnd);\n    } else if (context.now === internals.components.contextComment) {\n      updateResult(internals.diagnoses.errUnclosedComment);\n    } else if (context.now === internals.components.literal) {\n      updateResult(internals.diagnoses.errUnclosedDomainLiteral);\n    } else if (token === '\\r') {\n      updateResult(internals.diagnoses.errFWSCRLFEnd);\n    } else if (parseData.domain.length === 0) {\n      updateResult(internals.diagnoses.errNoDomain);\n    } else if (elementLength === 0) {\n      updateResult(internals.diagnoses.errDotEnd);\n    } else if (hyphenFlag) {\n      updateResult(internals.diagnoses.errDomainHyphenEnd);\n    } // Other errors\n    else if (punycodeLength > 255) {\n        // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.2\n        //   The maximum total length of a domain name or number is 255 octets.\n        updateResult(internals.diagnoses.rfc5322DomainTooLong);\n      } else if (Buffer.byteLength(parseData.local, 'utf8') + punycodeLength +\n      /* '@' */\n      1 > 254) {\n        // http://tools.ietf.org/html/rfc5321#section-4.1.2\n        //   Forward-path   = Path\n        //\n        //   Path           = \"<\" [ A-d-l \":\" ] Mailbox \">\"\n        //\n        // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3\n        //   The maximum total length of a reverse-path or forward-path is 256 octets (including the punctuation and element separators).\n        //\n        // Thus, even without (obsolete) routing information, the Mailbox can only be 254 characters long. This is confirmed by this verified\n        // erratum to RFC 3696:\n        //\n        // http://www.rfc-editor.org/errata_search.php?rfc=3696&eid=1690\n        //   However, there is a restriction in RFC 2821 on the length of an address in MAIL and RCPT commands of 254 characters.  Since\n        //   addresses that do not fit in those fields are not normally useful, the upper limit on address lengths should normally be considered\n        //   to be 254.\n        updateResult(internals.diagnoses.rfc5322TooLong);\n      } else if (elementLength > 63) {\n        // http://tools.ietf.org/html/rfc1035#section-2.3.4\n        // labels   63 octets or less\n        updateResult(internals.diagnoses.rfc5322LabelTooLong);\n      } else if (options.minDomainAtoms && atomData.domains.length < options.minDomainAtoms && (atomData.domains.length !== 1 || atomData.domains[0][0] !== '[')) {\n        updateResult(internals.diagnoses.errDomainTooShort);\n      } else if (internals.hasDomainLiteralThenAtom(atomData.domains)) {\n        updateResult(internals.diagnoses.errDotAfterDomainLiteral);\n      } else if (options.tldWhitelist || options.tldBlacklist) {\n        const tldAtom = atomData.domains[elementCount];\n\n        if (!internals.validDomain(tldAtom, options)) {\n          updateResult(internals.diagnoses.errUnknownTLD);\n        }\n      }\n  } // Check for errors\n  // Finish\n\n\n  if (maxResult < internals.categories.dnsWarn) {\n    // Per RFC 5321, domain atoms are limited to letter-digit-hyphen, so we only need to check code <= 57 to check for a digit\n    const code = atomData.domains[elementCount].codePointAt(0);\n\n    if (code <= 57) {\n      updateResult(internals.diagnoses.rfc5321TLDNumeric);\n    }\n  }\n\n  if (maxResult < threshold) {\n    maxResult = internals.diagnoses.valid;\n  }\n\n  const finishResult = diagnose ? maxResult : maxResult < internals.defaultThreshold; // $lab:coverage:off$\n\n  if (callback) {\n    callback(finishResult);\n  } // $lab:coverage:on$\n\n\n  return finishResult;\n};\n\nexports.diagnoses = internals.validate.diagnoses = function () {\n  const diag = {};\n  const keys = Object.keys(internals.diagnoses);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    diag[key] = internals.diagnoses[key];\n  }\n\n  return diag;\n}();\n\nexports.normalize = internals.normalize;","map":{"version":3,"sources":["/home/kosidocs/Web Development/React-Development/contact-us-form/node_modules/isemail/lib/index.js"],"names":["Punycode","require","Util","internals","hasOwn","Object","prototype","hasOwnProperty","indexOf","Array","defaultThreshold","maxIPv6Groups","categories","valid","dnsWarn","rfc5321","cfws","deprecated","rfc5322","error","diagnoses","rfc5321TLD","rfc5321TLDNumeric","rfc5321QuotedString","rfc5321AddressLiteral","cfwsComment","cfwsFWS","undesiredNonAscii","deprecatedLocalPart","deprecatedFWS","deprecatedQTEXT","deprecatedQP","deprecatedComment","deprecatedCTEXT","deprecatedIPv6","deprecatedCFWSNearAt","rfc5322Domain","rfc5322TooLong","rfc5322LocalTooLong","rfc5322DomainTooLong","rfc5322LabelTooLong","rfc5322DomainLiteral","rfc5322DomainLiteralOBSDText","rfc5322IPv6GroupCount","rfc5322IPv62x2xColon","rfc5322IPv6BadCharacter","rfc5322IPv6MaxGroups","rfc5322IPv6ColonStart","rfc5322IPv6ColonEnd","errExpectingDTEXT","errNoLocalPart","errNoDomain","errConsecutiveDots","errATEXTAfterCFWS","errATEXTAfterQS","errATEXTAfterDomainLiteral","errExpectingQPair","errExpectingATEXT","errExpectingQTEXT","errExpectingCTEXT","errBackslashEnd","errDotStart","errDotEnd","errDomainHyphenStart","errDomainHyphenEnd","errUnclosedQuotedString","errUnclosedComment","errUnclosedDomainLiteral","errFWSCRLFx2","errFWSCRLFEnd","errCRNoLF","errUnknownTLD","errDomainTooShort","errDotAfterDomainLiteral","components","localpart","domain","literal","contextComment","contextFWS","contextQuotedString","contextQuotedPair","specials","lookup","fill","i","length","codePointAt","code","c0Controls","c1Controls","regex","ipV4","ipV6","normalizeSupportsNul","normalize","nulNormalize","email","split","map","part","join","checkIpV6","items","every","value","test","isIterable","isArray","Symbol","iterator","_isSet","Set","_isMap","Map","isSet","types","isMap","normalizeTable","table","keys","canonicalizeAtom","atom","toASCII","toLowerCase","includesMapped","iterable","iteratee","item","validDomain","tldAtom","options","canonicalTldAtom","tldBlacklist","tldWhitelist","hasDomainLiteralThenAtom","domainAtoms","hasDomainLiteral","exports","validate","callback","TypeError","diagnose","threshold","errorLevel","minDomainAtoms","excludeDiagnoses","maxResult","updateResult","has","allowUnicode","undefined","context","now","prev","stack","prevToken","parseData","local","atomData","locals","domains","elementCount","elementLength","crlfCount","charCode","hyphenFlag","assertEnd","emailLength","token","String","fromCodePoint","push","Buffer","byteLength","Error","punycodeLength","index","addressLiteral","matchesIP","exec","slice","match","maxGroups","groups","lastIndexOf","pop","escapeToken","finishResult","diag","key"],"mappings":"AAAA,a,CAEA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB,C,CAEA;;;AAEA,MAAME,SAAS,GAAG;AACdC,EAAAA,MAAM,EAAEC,MAAM,CAACC,SAAP,CAAiBC,cADX;AAEdC,EAAAA,OAAO,EAAEC,KAAK,CAACH,SAAN,CAAgBE,OAFX;AAGdE,EAAAA,gBAAgB,EAAE,EAHJ;AAIdC,EAAAA,aAAa,EAAE,CAJD;AAMdC,EAAAA,UAAU,EAAE;AACRC,IAAAA,KAAK,EAAE,CADC;AAERC,IAAAA,OAAO,EAAE,CAFD;AAGRC,IAAAA,OAAO,EAAE,EAHD;AAIRC,IAAAA,IAAI,EAAE,EAJE;AAKRC,IAAAA,UAAU,EAAE,EALJ;AAMRC,IAAAA,OAAO,EAAE,GAND;AAORC,IAAAA,KAAK,EAAE;AAPC,GANE;AAgBdC,EAAAA,SAAS,EAAE;AAEP;AAEAP,IAAAA,KAAK,EAAE,CAJA;AAMP;AAEAQ,IAAAA,UAAU,EAAE,CARL;AASPC,IAAAA,iBAAiB,EAAE,EATZ;AAUPC,IAAAA,mBAAmB,EAAE,EAVd;AAWPC,IAAAA,qBAAqB,EAAE,EAXhB;AAaP;AAEAC,IAAAA,WAAW,EAAE,EAfN;AAgBPC,IAAAA,OAAO,EAAE,EAhBF;AAkBP;AACA;AACA;AACAC,IAAAA,iBAAiB,EAAE,EArBZ;AAuBP;AAEAC,IAAAA,mBAAmB,EAAE,EAzBd;AA0BPC,IAAAA,aAAa,EAAE,EA1BR;AA2BPC,IAAAA,eAAe,EAAE,EA3BV;AA4BPC,IAAAA,YAAY,EAAE,EA5BP;AA6BPC,IAAAA,iBAAiB,EAAE,EA7BZ;AA8BPC,IAAAA,eAAe,EAAE,EA9BV;AA+BPC,IAAAA,cAAc,EAAE,EA/BT;AAgCPC,IAAAA,oBAAoB,EAAE,EAhCf;AAkCP;AAEAC,IAAAA,aAAa,EAAE,EApCR;AAqCPC,IAAAA,cAAc,EAAE,EArCT;AAsCPC,IAAAA,mBAAmB,EAAE,EAtCd;AAuCPC,IAAAA,oBAAoB,EAAE,EAvCf;AAwCPC,IAAAA,mBAAmB,EAAE,EAxCd;AAyCPC,IAAAA,oBAAoB,EAAE,EAzCf;AA0CPC,IAAAA,4BAA4B,EAAE,EA1CvB;AA2CPC,IAAAA,qBAAqB,EAAE,EA3ChB;AA4CPC,IAAAA,oBAAoB,EAAE,EA5Cf;AA6CPC,IAAAA,uBAAuB,EAAE,EA7ClB;AA8CPC,IAAAA,oBAAoB,EAAE,EA9Cf;AA+CPC,IAAAA,qBAAqB,EAAE,EA/ChB;AAgDPC,IAAAA,mBAAmB,EAAE,EAhDd;AAkDP;AAEAC,IAAAA,iBAAiB,EAAE,GApDZ;AAqDPC,IAAAA,cAAc,EAAE,GArDT;AAsDPC,IAAAA,WAAW,EAAE,GAtDN;AAuDPC,IAAAA,kBAAkB,EAAE,GAvDb;AAwDPC,IAAAA,iBAAiB,EAAE,GAxDZ;AAyDPC,IAAAA,eAAe,EAAE,GAzDV;AA0DPC,IAAAA,0BAA0B,EAAE,GA1DrB;AA2DPC,IAAAA,iBAAiB,EAAE,GA3DZ;AA4DPC,IAAAA,iBAAiB,EAAE,GA5DZ;AA6DPC,IAAAA,iBAAiB,EAAE,GA7DZ;AA8DPC,IAAAA,iBAAiB,EAAE,GA9DZ;AA+DPC,IAAAA,eAAe,EAAE,GA/DV;AAgEPC,IAAAA,WAAW,EAAE,GAhEN;AAiEPC,IAAAA,SAAS,EAAE,GAjEJ;AAkEPC,IAAAA,oBAAoB,EAAE,GAlEf;AAmEPC,IAAAA,kBAAkB,EAAE,GAnEb;AAoEPC,IAAAA,uBAAuB,EAAE,GApElB;AAqEPC,IAAAA,kBAAkB,EAAE,GArEb;AAsEPC,IAAAA,wBAAwB,EAAE,GAtEnB;AAuEPC,IAAAA,YAAY,EAAE,GAvEP;AAwEPC,IAAAA,aAAa,EAAE,GAxER;AAyEPC,IAAAA,SAAS,EAAE,GAzEJ;AA0EPC,IAAAA,aAAa,EAAE,GA1ER;AA2EPC,IAAAA,iBAAiB,EAAE,GA3EZ;AA4EPC,IAAAA,wBAAwB,EAAE;AA5EnB,GAhBG;AA+FdC,EAAAA,UAAU,EAAE;AACRC,IAAAA,SAAS,EAAE,CADH;AAERC,IAAAA,MAAM,EAAE,CAFA;AAGRC,IAAAA,OAAO,EAAE,CAHD;AAIRC,IAAAA,cAAc,EAAE,CAJR;AAKRC,IAAAA,UAAU,EAAE,CALJ;AAMRC,IAAAA,mBAAmB,EAAE,CANb;AAORC,IAAAA,iBAAiB,EAAE;AAPX;AA/FE,CAAlB;;AA2GA9E,SAAS,CAAC+E,QAAV,GAAqB,YAAY;AAE7B,QAAMA,QAAQ,GAAG,gBAAjB,CAF6B,CAEa;;AAC1C,QAAMC,MAAM,GAAG,IAAI1E,KAAJ,CAAU,KAAV,CAAf;AACA0E,EAAAA,MAAM,CAACC,IAAP,CAAY,KAAZ;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,QAAQ,CAACI,MAA7B,EAAqC,EAAED,CAAvC,EAA0C;AACtCF,IAAAA,MAAM,CAACD,QAAQ,CAACK,WAAT,CAAqBF,CAArB,CAAD,CAAN,GAAkC,IAAlC;AACH;;AAED,SAAO,UAAUG,IAAV,EAAgB;AAEnB,WAAOL,MAAM,CAACK,IAAD,CAAb;AACH,GAHD;AAIH,CAdoB,EAArB;;AAgBArF,SAAS,CAACsF,UAAV,GAAuB,YAAY;AAE/B,QAAMN,MAAM,GAAG,IAAI1E,KAAJ,CAAU,KAAV,CAAf;AACA0E,EAAAA,MAAM,CAACC,IAAP,CAAY,KAAZ,EAH+B,CAK/B;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,EAApB,EAAwB,EAAEA,CAA1B,EAA6B;AACzBF,IAAAA,MAAM,CAACE,CAAD,CAAN,GAAY,IAAZ;AACH;;AAED,SAAO,UAAUG,IAAV,EAAgB;AAEnB,WAAOL,MAAM,CAACK,IAAD,CAAb;AACH,GAHD;AAIH,CAfsB,EAAvB;;AAiBArF,SAAS,CAACuF,UAAV,GAAuB,YAAY;AAE/B,QAAMP,MAAM,GAAG,IAAI1E,KAAJ,CAAU,KAAV,CAAf;AACA0E,EAAAA,MAAM,CAACC,IAAP,CAAY,KAAZ,EAH+B,CAK/B;;AAEA,OAAK,IAAIC,CAAC,GAAG,GAAb,EAAkBA,CAAC,GAAG,GAAtB,EAA2B,EAAEA,CAA7B,EAAgC;AAC5BF,IAAAA,MAAM,CAACE,CAAD,CAAN,GAAY,IAAZ;AACH;;AAED,SAAO,UAAUG,IAAV,EAAgB;AAEnB,WAAOL,MAAM,CAACK,IAAD,CAAb;AACH,GAHD;AAIH,CAfsB,EAAvB;;AAiBArF,SAAS,CAACwF,KAAV,GAAkB;AACdC,EAAAA,IAAI,EAAE,4EADQ;AAEdC,EAAAA,IAAI,EAAE;AAFQ,CAAlB;AAKA1F,SAAS,CAAC2F,oBAAV,GAAiC,KAAKC,SAAL,CAAe,KAAf,MAA0B,IAA3D,C,CAGA;;AACA5F,SAAS,CAAC6F,YAAV,GAAyB,UAAUC,KAAV,EAAiB;AAEtC,SAAOA,KAAK,CAACC,KAAN,CAAY,IAAZ,EAAkBC,GAAlB,CAAuBC,IAAD,IAAUA,IAAI,CAACL,SAAL,CAAe,KAAf,CAAhC,EAAuDM,IAAvD,CAA4D,IAA5D,CAAP;AACH,CAHD,C,CAIA;;;AAGAlG,SAAS,CAAC4F,SAAV,GAAsB,UAAUE,KAAV,EAAiB;AAEnC,SAAOA,KAAK,CAACF,SAAN,CAAgB,KAAhB,CAAP;AACH,CAHD,C,CAMA;;;AACA,IAAI,CAAC5F,SAAS,CAAC2F,oBAAf,EAAqC;AACjC3F,EAAAA,SAAS,CAAC4F,SAAV,GAAsB,UAAUE,KAAV,EAAiB;AAEnC,QAAIA,KAAK,CAACzF,OAAN,CAAc,IAAd,KAAuB,CAA3B,EAA8B;AAC1B,aAAOL,SAAS,CAAC6F,YAAV,CAAuBC,KAAvB,CAAP;AACH;;AAED,WAAOA,KAAK,CAACF,SAAN,CAAgB,KAAhB,CAAP;AACH,GAPD;AAQH,C,CACD;;;AAGA5F,SAAS,CAACmG,SAAV,GAAsB,UAAUC,KAAV,EAAiB;AAEnC,SAAOA,KAAK,CAACC,KAAN,CAAaC,KAAD,IAAWtG,SAAS,CAACwF,KAAV,CAAgBE,IAAhB,CAAqBa,IAArB,CAA0BD,KAA1B,CAAvB,CAAP;AACH,CAHD;;AAMAtG,SAAS,CAACwG,UAAV,GAAuBlG,KAAK,CAACmG,OAA7B;AAGA;;AACA,IAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;AAC/B1G,EAAAA,SAAS,CAACwG,UAAV,GAAwBF,KAAD,IAAWhG,KAAK,CAACmG,OAAN,CAAcH,KAAd,KAAyB,CAAC,CAACA,KAAF,IAAW,OAAOA,KAAP,KAAiB,QAA5B,IAAwC,OAAOA,KAAK,CAACI,MAAM,CAACC,QAAR,CAAZ,KAAkC,UAArI;AACH;AACD;AAGA;AACA;AACA;;;AACA3G,SAAS,CAAC4G,MAAV,GAAoBN,KAAD,IAAWA,KAAK,YAAYO,GAA/C;;AACA7G,SAAS,CAAC8G,MAAV,GAAoBR,KAAD,IAAWA,KAAK,YAAYS,GAA/C;;AACA/G,SAAS,CAACgH,KAAV,GAAkBjH,IAAI,CAACkH,KAAL,IAAclH,IAAI,CAACkH,KAAL,CAAWD,KAAzB,IAAkChH,SAAS,CAAC4G,MAA9D;AACA5G,SAAS,CAACkH,KAAV,GAAkBnH,IAAI,CAACkH,KAAL,IAAclH,IAAI,CAACkH,KAAL,CAAWC,KAAzB,IAAkClH,SAAS,CAAC8G,MAA9D,C,CACA;;AAGA;;;;;;;;;AAQA9G,SAAS,CAACmH,cAAV,GAA2B,UAAUC,KAAV,EAAiB;AAExC,MAAIpH,SAAS,CAACgH,KAAV,CAAgBI,KAAhB,KAA0B9G,KAAK,CAACmG,OAAN,CAAcW,KAAd,CAA9B,EAAoD;AAChD,WAAOA,KAAP;AACH;;AAED,MAAIpH,SAAS,CAACkH,KAAV,CAAgBE,KAAhB,CAAJ,EAA4B;AACxB,WAAOA,KAAK,CAACC,IAAN,EAAP;AACH;;AAED,SAAOnH,MAAM,CAACmH,IAAP,CAAYD,KAAZ,CAAP;AACH,CAXD;AAcA;;;;;;;;;;;AASApH,SAAS,CAACsH,gBAAV,GAA6B,UAAUC,IAAV,EAAgB;AAEzC,SAAO1H,QAAQ,CAAC2H,OAAT,CAAiBD,IAAjB,EAAuBE,WAAvB,EAAP;AACH,CAHD;AAMA;;;;;;;;;;;;;AAWAzH,SAAS,CAAC0H,cAAV,GAA2B,UAAUC,QAAV,EAAoBC,QAApB,EAA8BtB,KAA9B,EAAqC;AAE5D,OAAK,MAAMuB,IAAX,IAAmBF,QAAnB,EAA6B;AACzB,QAAIrB,KAAK,KAAKsB,QAAQ,CAACC,IAAD,CAAtB,EAA8B;AAC1B,aAAO,IAAP;AACH;AACJ;;AAED,SAAO,KAAP;AACH,CATD;AAYA;;;;;;;;;;;;;AAWA7H,SAAS,CAAC8H,WAAV,GAAwB,UAAUC,OAAV,EAAmBC,OAAnB,EAA4B;AAEhD;AACA;AACA,QAAMC,gBAAgB,GAAGjI,SAAS,CAACsH,gBAAV,CAA2BS,OAA3B,CAAzB;;AAEA,MAAIC,OAAO,CAACE,YAAZ,EAA0B;AACtB,WAAO,CAAClI,SAAS,CAAC0H,cAAV,CACJ1H,SAAS,CAACmH,cAAV,CAAyBa,OAAO,CAACE,YAAjC,CADI,EAEJlI,SAAS,CAACsH,gBAFN,EAEwBW,gBAFxB,CAAR;AAGH;;AAED,SAAOjI,SAAS,CAAC0H,cAAV,CACH1H,SAAS,CAACmH,cAAV,CAAyBa,OAAO,CAACG,YAAjC,CADG,EAEHnI,SAAS,CAACsH,gBAFP,EAEyBW,gBAFzB,CAAP;AAGH,CAfD;AAkBA;;;;;;;;;;AAQAjI,SAAS,CAACoI,wBAAV,GAAqC,UAAUC,WAAV,EAAuB;AAExD,MAAIC,gBAAgB,GAAG,KAAvB;;AACA,OAAK,IAAIpD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmD,WAAW,CAAClD,MAAhC,EAAwC,EAAED,CAA1C,EAA6C;AACzC,QAAImD,WAAW,CAACnD,CAAD,CAAX,CAAe,CAAf,MAAsB,GAA1B,EAA+B;AAC3BoD,MAAAA,gBAAgB,GAAG,IAAnB;AACH,KAFD,MAGK,IAAIA,gBAAJ,EAAsB;AACvB,aAAO,IAAP;AACH;AACJ;;AAED,SAAO,KAAP;AACH,CAbD;AAgBA;;;;;;;;;;;;;;;;;;;;;;AAqBAC,OAAO,CAACC,QAAR,GAAmBxI,SAAS,CAACwI,QAAV,GAAqB,UAAU1C,KAAV,EAAiBkC,OAAjB,EAA0BS,QAA1B,EAAoC;AAExET,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,MAAI,OAAOlC,KAAP,KAAiB,QAArB,EAA+B;AAC3B,UAAM,IAAI4C,SAAJ,CAAc,uBAAd,CAAN;AACH;;AAED5C,EAAAA,KAAK,GAAG9F,SAAS,CAAC4F,SAAV,CAAoBE,KAApB,CAAR,CARwE,CAUxE;AACA;;AACA,MAAI,OAAOkC,OAAP,KAAmB,UAAvB,EAAmC;AAC/BS,IAAAA,QAAQ,GAAGT,OAAX;AACAA,IAAAA,OAAO,GAAG,EAAV;AACH;;AAED,MAAI,OAAOS,QAAP,KAAoB,UAAxB,EAAoC;AAChCA,IAAAA,QAAQ,GAAG,IAAX;AACH,GAnBuE,CAoBxE;;;AAEA,MAAIE,QAAJ;AACA,MAAIC,SAAJ;;AAEA,MAAI,OAAOZ,OAAO,CAACa,UAAf,KAA8B,QAAlC,EAA4C;AACxCF,IAAAA,QAAQ,GAAG,IAAX;AACAC,IAAAA,SAAS,GAAGZ,OAAO,CAACa,UAApB;AACH,GAHD,MAIK;AACDF,IAAAA,QAAQ,GAAG,CAAC,CAACX,OAAO,CAACa,UAArB;AACAD,IAAAA,SAAS,GAAG5I,SAAS,CAACiB,SAAV,CAAoBP,KAAhC;AACH;;AAED,MAAIsH,OAAO,CAACG,YAAZ,EAA0B;AACtB,QAAI,OAAOH,OAAO,CAACG,YAAf,KAAgC,QAApC,EAA8C;AAC1CH,MAAAA,OAAO,CAACG,YAAR,GAAuB,CAACH,OAAO,CAACG,YAAT,CAAvB;AACH,KAFD,MAGK,IAAI,OAAOH,OAAO,CAACG,YAAf,KAAgC,QAApC,EAA8C;AAC/C,YAAM,IAAIO,SAAJ,CAAc,uCAAd,CAAN;AACH;AACJ;;AAED,MAAIV,OAAO,CAACE,YAAZ,EAA0B;AACtB,QAAI,OAAOF,OAAO,CAACE,YAAf,KAAgC,QAApC,EAA8C;AAC1CF,MAAAA,OAAO,CAACE,YAAR,GAAuB,CAACF,OAAO,CAACE,YAAT,CAAvB;AACH,KAFD,MAGK,IAAI,OAAOF,OAAO,CAACE,YAAf,KAAgC,QAApC,EAA8C;AAC/C,YAAM,IAAIQ,SAAJ,CAAc,uCAAd,CAAN;AACH;AACJ;;AAED,MAAIV,OAAO,CAACc,cAAR,KAA2Bd,OAAO,CAACc,cAAR,MAA6B,CAACd,OAAO,CAACc,cAAV,GAA4B,CAAxD,KAA8Dd,OAAO,CAACc,cAAR,GAAyB,CAAlH,CAAJ,EAA0H;AACtH,UAAM,IAAIJ,SAAJ,CAAc,0CAAd,CAAN;AACH,GAtDuE,CAwDxE;;;AACA,MAAIV,OAAO,CAACe,gBAAZ,EAA8B;AAC1B,QAAI,CAAC/I,SAAS,CAACwG,UAAV,CAAqBwB,OAAO,CAACe,gBAA7B,CAAL,EAAqD;AACjD,YAAM,IAAIL,SAAJ,CAAc,oCAAd,CAAN;AACH,KAHyB,CAK1B;AACA;;;AACA,QAAI,CAAC1I,SAAS,CAACgH,KAAV,CAAgBgB,OAAO,CAACe,gBAAxB,CAAL,EAAgD;AAC5Cf,MAAAA,OAAO,CAACe,gBAAR,GAA2B,IAAIlC,GAAJ,CAAQmB,OAAO,CAACe,gBAAhB,CAA3B;AACH;AACJ;;AAED,MAAIC,SAAS,GAAGhJ,SAAS,CAACiB,SAAV,CAAoBP,KAApC;;AACA,QAAMuI,YAAY,GAAI3C,KAAD,IAAW;AAE5B,QAAIA,KAAK,GAAG0C,SAAR,KAAsB,CAAChB,OAAO,CAACe,gBAAT,IAA6B,CAACf,OAAO,CAACe,gBAAR,CAAyBG,GAAzB,CAA6B5C,KAA7B,CAApD,CAAJ,EAA8F;AAC1F0C,MAAAA,SAAS,GAAG1C,KAAZ;AACH;AACJ,GALD;;AAOA,QAAM6C,YAAY,GAAGnB,OAAO,CAACmB,YAAR,KAAyBC,SAAzB,IAAsC,CAAC,CAACpB,OAAO,CAACmB,YAArE;;AACA,MAAI,CAACA,YAAD,IAAiB,eAAe5C,IAAf,CAAoBT,KAApB,CAArB,EAAiD;AAC7CmD,IAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBO,iBAArB,CAAZ;AACH;;AAED,QAAM6H,OAAO,GAAG;AACZC,IAAAA,GAAG,EAAEtJ,SAAS,CAACuE,UAAV,CAAqBC,SADd;AAEZ+E,IAAAA,IAAI,EAAEvJ,SAAS,CAACuE,UAAV,CAAqBC,SAFf;AAGZgF,IAAAA,KAAK,EAAE,CAACxJ,SAAS,CAACuE,UAAV,CAAqBC,SAAtB;AAHK,GAAhB;AAMA,MAAIiF,SAAS,GAAG,EAAhB;AAEA,QAAMC,SAAS,GAAG;AACdC,IAAAA,KAAK,EAAE,EADO;AAEdlF,IAAAA,MAAM,EAAE;AAFM,GAAlB;AAIA,QAAMmF,QAAQ,GAAG;AACbC,IAAAA,MAAM,EAAE,CAAC,EAAD,CADK;AAEbC,IAAAA,OAAO,EAAE,CAAC,EAAD;AAFI,GAAjB;AAKA,MAAIC,YAAY,GAAG,CAAnB;AACA,MAAIC,aAAa,GAAG,CAApB;AACA,MAAIC,SAAS,GAAG,CAAhB;AACA,MAAIC,QAAJ;AAEA,MAAIC,UAAU,GAAG,KAAjB;AACA,MAAIC,SAAS,GAAG,KAAhB;AAEA,QAAMC,WAAW,GAAGvE,KAAK,CAACX,MAA1B;AAEA,MAAImF,KAAJ,CA7GwE,CA6GxB;;AAChD,OAAK,IAAIpF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmF,WAApB,EAAiCnF,CAAC,IAAIoF,KAAK,CAACnF,MAA5C,EAAoD;AAChD;AACAmF,IAAAA,KAAK,GAAGC,MAAM,CAACC,aAAP,CAAqB1E,KAAK,CAACV,WAAN,CAAkBF,CAAlB,CAArB,CAAR;;AAEA,YAAQmE,OAAO,CAACC,GAAhB;AACI;AACA,WAAKtJ,SAAS,CAACuE,UAAV,CAAqBC,SAA1B;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAQ8F,KAAR;AACI;AACA,eAAK,GAAL;AACI,gBAAIN,aAAa,KAAK,CAAtB,EAAyB;AACrB;AACAf,cAAAA,YAAY,CAACc,YAAY,KAAK,CAAjB,GAAqB/J,SAAS,CAACiB,SAAV,CAAoBK,WAAzC,GAAuDtB,SAAS,CAACiB,SAAV,CAAoBY,iBAA5E,CAAZ;AACH,aAHD,MAIK;AACDoH,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBK,WAArB,CAAZ,CADC,CAED;;AACA8I,cAAAA,SAAS,GAAG,IAAZ;AACH;;AAEDf,YAAAA,OAAO,CAACG,KAAR,CAAciB,IAAd,CAAmBpB,OAAO,CAACC,GAA3B;AACAD,YAAAA,OAAO,CAACC,GAAR,GAActJ,SAAS,CAACuE,UAAV,CAAqBI,cAAnC;AACA;AAEA;;AACJ,eAAK,GAAL;AACI,gBAAIqF,aAAa,KAAK,CAAtB,EAAyB;AACrB;AACAf,cAAAA,YAAY,CAACc,YAAY,KAAK,CAAjB,GAAqB/J,SAAS,CAACiB,SAAV,CAAoByC,WAAzC,GAAuD1D,SAAS,CAACiB,SAAV,CAAoBgC,kBAA5E,CAAZ;AACH,aAHD,MAIK;AACD;AACA,kBAAImH,SAAJ,EAAe;AACXnB,gBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBQ,mBAArB,CAAZ;AACH,eAJA,CAMD;;;AACA2I,cAAAA,SAAS,GAAG,KAAZ;AACAJ,cAAAA,aAAa,GAAG,CAAhB;AACA,gBAAED,YAAF;AACAL,cAAAA,SAAS,CAACC,KAAV,IAAmBW,KAAnB;AACAV,cAAAA,QAAQ,CAACC,MAAT,CAAgBE,YAAhB,IAAgC,EAAhC;AACH;;AAED;AAEA;;AACJ,eAAK,GAAL;AACI,gBAAIC,aAAa,KAAK,CAAtB,EAAyB;AACrB;AACAf,cAAAA,YAAY,CAACc,YAAY,KAAK,CAAjB,GAAqB/J,SAAS,CAACiB,SAAV,CAAoBG,mBAAzC,GAA+DpB,SAAS,CAACiB,SAAV,CAAoBQ,mBAApF,CAAZ;AAEAiI,cAAAA,SAAS,CAACC,KAAV,IAAmBW,KAAnB;AACAV,cAAAA,QAAQ,CAACC,MAAT,CAAgBE,YAAhB,KAAiCO,KAAjC;AACAN,cAAAA,aAAa,IAAIU,MAAM,CAACC,UAAP,CAAkBL,KAAlB,EAAyB,MAAzB,CAAjB,CANqB,CAQrB;;AACAF,cAAAA,SAAS,GAAG,IAAZ;AACAf,cAAAA,OAAO,CAACG,KAAR,CAAciB,IAAd,CAAmBpB,OAAO,CAACC,GAA3B;AACAD,cAAAA,OAAO,CAACC,GAAR,GAActJ,SAAS,CAACuE,UAAV,CAAqBM,mBAAnC;AACH,aAZD,MAaK;AACDoE,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBqC,iBAArB,CAAZ;AACH;;AAED;AAEA;;AACJ,eAAK,IAAL;AACI,gBAAI+G,WAAW,KAAK,EAAEnF,CAAlB,IAAuBY,KAAK,CAACZ,CAAD,CAAL,KAAa,IAAxC,EAA8C;AAC1C;AACA+D,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBkD,SAArB,CAAZ;AACA;AACH;;AAED;;AAEJ,eAAK,GAAL;AACA,eAAK,IAAL;AACI,gBAAI6F,aAAa,KAAK,CAAtB,EAAyB;AACrBf,cAAAA,YAAY,CAACc,YAAY,KAAK,CAAjB,GAAqB/J,SAAS,CAACiB,SAAV,CAAoBM,OAAzC,GAAmDvB,SAAS,CAACiB,SAAV,CAAoBS,aAAxE,CAAZ;AACH,aAFD,MAGK;AACD;AACA0I,cAAAA,SAAS,GAAG,IAAZ;AACH;;AAEDf,YAAAA,OAAO,CAACG,KAAR,CAAciB,IAAd,CAAmBpB,OAAO,CAACC,GAA3B;AACAD,YAAAA,OAAO,CAACC,GAAR,GAActJ,SAAS,CAACuE,UAAV,CAAqBK,UAAnC;AACA6E,YAAAA,SAAS,GAAGa,KAAZ;AACA;;AAEJ,eAAK,GAAL;AACI;AACA;AACA,gBAAIjB,OAAO,CAACG,KAAR,CAAcrE,MAAd,KAAyB,CAA7B,EAAgC;AAC5B,oBAAM,IAAIyF,KAAJ,CAAU,kCAAV,CAAN;AACH,aALL,CAMI;;;AAEA,gBAAIlB,SAAS,CAACC,KAAV,CAAgBxE,MAAhB,KAA2B,CAA/B,EAAkC;AAC9B;AACA8D,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoB8B,cAArB,CAAZ;AACH,aAHD,MAIK,IAAIiH,aAAa,KAAK,CAAtB,EAAyB;AAC1B;AACAf,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoB0C,SAArB,CAAZ;AACH,aAHI,CAIL;AACA;AALK,iBAMA,IAAI+G,MAAM,CAACC,UAAP,CAAkBjB,SAAS,CAACC,KAA5B,EAAmC,MAAnC,IAA6C,EAAjD,EAAqD;AACtDV,gBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBkB,mBAArB,CAAZ;AACH,eAFI,CAGL;AACA;AACA;AACA;AACA;AACA;AACA;AATK,mBAUA,IAAIkH,OAAO,CAACE,IAAR,KAAiBvJ,SAAS,CAACuE,UAAV,CAAqBI,cAAtC,IAAwD0E,OAAO,CAACE,IAAR,KAAiBvJ,SAAS,CAACuE,UAAV,CAAqBK,UAAlG,EAA8G;AAC/GqE,kBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBe,oBAArB,CAAZ;AACH,iBA9BL,CAgCI;;;AACAqH,YAAAA,OAAO,CAACC,GAAR,GAActJ,SAAS,CAACuE,UAAV,CAAqBE,MAAnC;AACA4E,YAAAA,OAAO,CAACG,KAAR,CAAc,CAAd,IAAmBxJ,SAAS,CAACuE,UAAV,CAAqBE,MAAxC;AACAsF,YAAAA,YAAY,GAAG,CAAf;AACAC,YAAAA,aAAa,GAAG,CAAhB;AACAI,YAAAA,SAAS,GAAG,KAAZ,CArCJ,CAqCuB;;AACnB;AAEA;;AACJ;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAIA,SAAJ,EAAe;AACX;AACA,sBAAQf,OAAO,CAACE,IAAhB;AACI,qBAAKvJ,SAAS,CAACuE,UAAV,CAAqBI,cAA1B;AACA,qBAAK3E,SAAS,CAACuE,UAAV,CAAqBK,UAA1B;AACIqE,kBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBiC,iBAArB,CAAZ;AACA;;AAEJ,qBAAKlD,SAAS,CAACuE,UAAV,CAAqBM,mBAA1B;AACIoE,kBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBkC,eAArB,CAAZ;AACA;AAEA;;AACJ;AACI,wBAAM,IAAIyH,KAAJ,CAAU,4EAA4EvB,OAAO,CAACE,IAA9F,CAAN;AACA;AAbR;AAeH,aAjBD,MAkBK;AACDF,cAAAA,OAAO,CAACE,IAAR,GAAeF,OAAO,CAACC,GAAvB;AACAY,cAAAA,QAAQ,GAAGI,KAAK,CAAClF,WAAN,CAAkB,CAAlB,CAAX,CAFC,CAID;;AACA,kBAAIpF,SAAS,CAAC+E,QAAV,CAAmBmF,QAAnB,KAAgClK,SAAS,CAACsF,UAAV,CAAqB4E,QAArB,CAAhC,IAAkElK,SAAS,CAACuF,UAAV,CAAqB2E,QAArB,CAAtE,EAAsG;AAElG;AACAjB,gBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBqC,iBAArB,CAAZ;AACH;;AAEDoG,cAAAA,SAAS,CAACC,KAAV,IAAmBW,KAAnB;AACAV,cAAAA,QAAQ,CAACC,MAAT,CAAgBE,YAAhB,KAAiCO,KAAjC;AACAN,cAAAA,aAAa,IAAIU,MAAM,CAACC,UAAP,CAAkBL,KAAlB,EAAyB,MAAzB,CAAjB;AACH;;AA3KT;;AA8KA;;AAEJ,WAAKtK,SAAS,CAACuE,UAAV,CAAqBE,MAA1B;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAQ6F,KAAR;AACI;AACA,eAAK,GAAL;AACI,gBAAIN,aAAa,KAAK,CAAtB,EAAyB;AACrB;AACA;AACAf,cAAAA,YAAY,CAACc,YAAY,KAAK,CAAjB,GAAqB/J,SAAS,CAACiB,SAAV,CAAoBe,oBAAzC,GAAgEhC,SAAS,CAACiB,SAAV,CAAoBY,iBAArF,CAAZ;AACH,aAJD,MAKK;AACD;AACAuI,cAAAA,SAAS,GAAG,IAAZ;AACAnB,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBK,WAArB,CAAZ;AACH;;AAED+H,YAAAA,OAAO,CAACG,KAAR,CAAciB,IAAd,CAAmBpB,OAAO,CAACC,GAA3B;AACAD,YAAAA,OAAO,CAACC,GAAR,GAActJ,SAAS,CAACuE,UAAV,CAAqBI,cAAnC;AACA;AAEA;;AACJ,eAAK,GAAL;AACI,kBAAMkG,cAAc,GAAGhL,QAAQ,CAAC2H,OAAT,CAAiBoC,QAAQ,CAACE,OAAT,CAAiBC,YAAjB,CAAjB,EAAiD5E,MAAxE;;AACA,gBAAI6E,aAAa,KAAK,CAAtB,EAAyB;AACrB;AACAf,cAAAA,YAAY,CAACc,YAAY,KAAK,CAAjB,GAAqB/J,SAAS,CAACiB,SAAV,CAAoByC,WAAzC,GAAuD1D,SAAS,CAACiB,SAAV,CAAoBgC,kBAA5E,CAAZ;AACH,aAHD,MAIK,IAAIkH,UAAJ,EAAgB;AACjB;AACAlB,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoB4C,kBAArB,CAAZ;AACH,aAHI,MAIA,IAAIgH,cAAc,GAAG,EAArB,EAAyB;AAC1B;AACA;AACA;AACA;AACA;AACA;AAEA5B,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBoB,mBAArB,CAAZ;AACH,aAnBL,CAqBI;AACA;;;AACA+H,YAAAA,SAAS,GAAG,KAAZ;AACAJ,YAAAA,aAAa,GAAG,CAAhB;AACA,cAAED,YAAF;AACAH,YAAAA,QAAQ,CAACE,OAAT,CAAiBC,YAAjB,IAAiC,EAAjC;AACAL,YAAAA,SAAS,CAACjF,MAAV,IAAoB6F,KAApB;AAEA;AAEA;;AACJ,eAAK,GAAL;AACI,gBAAIV,QAAQ,CAACE,OAAT,CAAiBC,YAAjB,EAA+B5E,MAA/B,KAA0C,CAA9C,EAAiD;AAC7C,kBAAIuE,SAAS,CAACjF,MAAV,CAAiBU,MAArB,EAA6B;AACzB;AACA8D,gBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBqD,wBAArB,CAAZ;AACH;;AAED8F,cAAAA,SAAS,GAAG,IAAZ;AACAJ,cAAAA,aAAa,IAAIU,MAAM,CAACC,UAAP,CAAkBL,KAAlB,EAAyB,MAAzB,CAAjB;AACAjB,cAAAA,OAAO,CAACG,KAAR,CAAciB,IAAd,CAAmBpB,OAAO,CAACC,GAA3B;AACAD,cAAAA,OAAO,CAACC,GAAR,GAActJ,SAAS,CAACuE,UAAV,CAAqBG,OAAnC;AACAgF,cAAAA,SAAS,CAACjF,MAAV,IAAoB6F,KAApB;AACAV,cAAAA,QAAQ,CAACE,OAAT,CAAiBC,YAAjB,KAAkCO,KAAlC;AACAZ,cAAAA,SAAS,CAAChF,OAAV,GAAoB,EAApB;AACH,aAbD,MAcK;AACD;AACAuE,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBqC,iBAArB,CAAZ;AACH;;AAED;AAEA;;AACJ,eAAK,IAAL;AACI,gBAAI+G,WAAW,KAAK,EAAEnF,CAAlB,IAAuBY,KAAK,CAACZ,CAAD,CAAL,KAAa,IAAxC,EAA8C;AAC1C;AACA+D,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBkD,SAArB,CAAZ;AACA;AACH;;AAED;;AAEJ,eAAK,GAAL;AACA,eAAK,IAAL;AACI,gBAAI6F,aAAa,KAAK,CAAtB,EAAyB;AACrBf,cAAAA,YAAY,CAACc,YAAY,KAAK,CAAjB,GAAqB/J,SAAS,CAACiB,SAAV,CAAoBe,oBAAzC,GAAgEhC,SAAS,CAACiB,SAAV,CAAoBS,aAArF,CAAZ;AACH,aAFD,MAGK;AACD;AACAuH,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBM,OAArB,CAAZ;AACA6I,cAAAA,SAAS,GAAG,IAAZ;AACH;;AAEDf,YAAAA,OAAO,CAACG,KAAR,CAAciB,IAAd,CAAmBpB,OAAO,CAACC,GAA3B;AACAD,YAAAA,OAAO,CAACC,GAAR,GAActJ,SAAS,CAACuE,UAAV,CAAqBK,UAAnC;AACA6E,YAAAA,SAAS,GAAGa,KAAZ;AACA;AAEA;;AACJ;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAIF,SAAJ,EAAe;AACX;AACA,sBAAQf,OAAO,CAACE,IAAhB;AACI,qBAAKvJ,SAAS,CAACuE,UAAV,CAAqBI,cAA1B;AACA,qBAAK3E,SAAS,CAACuE,UAAV,CAAqBK,UAA1B;AACIqE,kBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBiC,iBAArB,CAAZ;AACA;;AAEJ,qBAAKlD,SAAS,CAACuE,UAAV,CAAqBG,OAA1B;AACIuE,kBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBmC,0BAArB,CAAZ;AACA;AAEA;;AACJ;AACI,wBAAM,IAAIwH,KAAJ,CAAU,4EAA4EvB,OAAO,CAACE,IAA9F,CAAN;AACA;AAbR;AAeH;;AAEDW,YAAAA,QAAQ,GAAGI,KAAK,CAAClF,WAAN,CAAkB,CAAlB,CAAX,CA3CJ,CA4CI;;AACA+E,YAAAA,UAAU,GAAG,KAAb;;AAEA,gBAAInK,SAAS,CAAC+E,QAAV,CAAmBmF,QAAnB,KAAgClK,SAAS,CAACsF,UAAV,CAAqB4E,QAArB,CAAhC,IAAkElK,SAAS,CAACuF,UAAV,CAAqB2E,QAArB,CAAtE,EAAsG;AAClG;AACAjB,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBqC,iBAArB,CAAZ;AACH,aAHD,MAIK,IAAIgH,KAAK,KAAK,GAAd,EAAmB;AACpB,kBAAIN,aAAa,KAAK,CAAtB,EAAyB;AACrB;AACAf,gBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoB2C,oBAArB,CAAZ;AACH;;AAEDuG,cAAAA,UAAU,GAAG,IAAb;AACH,aAPI,CAQL;AARK,iBASA,IAAID,QAAQ,GAAG,EAAX,IAAkBA,QAAQ,GAAG,GAAX,IAAkBA,QAAQ,GAAG,GAA/C,IAAwDA,QAAQ,GAAG,EAAX,IAAiBA,QAAQ,GAAG,EAApF,IAA4FA,QAAQ,GAAG,EAAX,IAAiBA,QAAQ,GAAG,EAA5H,EAAiI;AAClI;AACAjB,gBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBgB,aAArB,CAAZ;AACH;;AAEDyH,YAAAA,SAAS,CAACjF,MAAV,IAAoB6F,KAApB;AACAV,YAAAA,QAAQ,CAACE,OAAT,CAAiBC,YAAjB,KAAkCO,KAAlC;AACAN,YAAAA,aAAa,IAAIU,MAAM,CAACC,UAAP,CAAkBL,KAAlB,EAAyB,MAAzB,CAAjB;AAvKR;;AA0KA;AAEA;;AACJ,WAAKtK,SAAS,CAACuE,UAAV,CAAqBG,OAA1B;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAQ4F,KAAR;AACI;AACA,eAAK,GAAL;AACI,gBAAItB,SAAS,GAAGhJ,SAAS,CAACS,UAAV,CAAqBK,UAArC,EAAiD;AAC7C;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,kBAAIgK,KAAK,GAAG,CAAC,CAAb;AACA,kBAAIC,cAAc,GAAGrB,SAAS,CAAChF,OAA/B;AACA,oBAAMsG,SAAS,GAAGhL,SAAS,CAACwF,KAAV,CAAgBC,IAAhB,CAAqBwF,IAArB,CAA0BF,cAA1B,CAAlB,CAlD6C,CAoD7C;;AACA,kBAAIC,SAAJ,EAAe;AACXF,gBAAAA,KAAK,GAAGE,SAAS,CAACF,KAAlB;;AACA,oBAAIA,KAAK,KAAK,CAAd,EAAiB;AACb;AACAC,kBAAAA,cAAc,GAAGA,cAAc,CAACG,KAAf,CAAqB,CAArB,EAAwBJ,KAAxB,IAAiC,KAAlD;AACH;AACJ;;AAED,kBAAIA,KAAK,KAAK,CAAd,EAAiB;AACb;AACA7B,gBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBI,qBAArB,CAAZ;AACH,eAHD,MAIK,IAAI0J,cAAc,CAACG,KAAf,CAAqB,CAArB,EAAwB,CAAxB,EAA2BzD,WAA3B,OAA6C,OAAjD,EAA0D;AAC3DwB,gBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBqB,oBAArB,CAAZ;AACH,eAFI,MAGA;AACD,sBAAM6I,KAAK,GAAGJ,cAAc,CAACG,KAAf,CAAqB,CAArB,CAAd;AACA,oBAAIE,SAAS,GAAGpL,SAAS,CAACQ,aAA1B;AACA,sBAAM6K,MAAM,GAAGF,KAAK,CAACpF,KAAN,CAAY,GAAZ,CAAf;AACA+E,gBAAAA,KAAK,GAAGK,KAAK,CAAC9K,OAAN,CAAc,IAAd,CAAR;;AAEA,oBAAI,CAAC,CAACyK,KAAN,EAAa;AACT;AACA,sBAAIO,MAAM,CAAClG,MAAP,KAAkBiG,SAAtB,EAAiC;AAC7BnC,oBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBuB,qBAArB,CAAZ;AACH;AACJ,iBALD,MAMK,IAAIsI,KAAK,KAAKK,KAAK,CAACG,WAAN,CAAkB,IAAlB,CAAd,EAAuC;AACxCrC,kBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBwB,oBAArB,CAAZ;AACH,iBAFI,MAGA;AACD,sBAAIqI,KAAK,KAAK,CAAV,IAAeA,KAAK,KAAKK,KAAK,CAAChG,MAAN,GAAe,CAA5C,EAA+C;AAC3C;AACA,sBAAEiG,SAAF;AACH;;AAED,sBAAIC,MAAM,CAAClG,MAAP,GAAgBiG,SAApB,EAA+B;AAC3BnC,oBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoB0B,oBAArB,CAAZ;AACH,mBAFD,MAGK,IAAI0I,MAAM,CAAClG,MAAP,KAAkBiG,SAAtB,EAAiC;AAClC;AACAnC,oBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBc,cAArB,CAAZ;AACH;AACJ,iBA5BA,CA8BD;;;AACA,oBAAIoJ,KAAK,CAAC,CAAD,CAAL,KAAa,GAAb,IAAoBA,KAAK,CAAC,CAAD,CAAL,KAAa,GAArC,EAA0C;AACtClC,kBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoB2B,qBAArB,CAAZ;AACH,iBAFD,MAGK,IAAIuI,KAAK,CAACA,KAAK,CAAChG,MAAN,GAAe,CAAhB,CAAL,KAA4B,GAA5B,IAAmCgG,KAAK,CAACA,KAAK,CAAChG,MAAN,GAAe,CAAhB,CAAL,KAA4B,GAAnE,EAAwE;AACzE8D,kBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoB4B,mBAArB,CAAZ;AACH,iBAFI,MAGA,IAAI7C,SAAS,CAACmG,SAAV,CAAoBkF,MAApB,CAAJ,EAAiC;AAClCpC,kBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBI,qBAArB,CAAZ;AACH,iBAFI,MAGA;AACD4H,kBAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoByB,uBAArB,CAAZ;AACH;AACJ;AACJ,aAhHD,MAiHK;AACDuG,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBqB,oBAArB,CAAZ;AACH;;AAEDoH,YAAAA,SAAS,CAACjF,MAAV,IAAoB6F,KAApB;AACAV,YAAAA,QAAQ,CAACE,OAAT,CAAiBC,YAAjB,KAAkCO,KAAlC;AACAN,YAAAA,aAAa,IAAIU,MAAM,CAACC,UAAP,CAAkBL,KAAlB,EAAyB,MAAzB,CAAjB;AACAjB,YAAAA,OAAO,CAACE,IAAR,GAAeF,OAAO,CAACC,GAAvB;AACAD,YAAAA,OAAO,CAACC,GAAR,GAAcD,OAAO,CAACG,KAAR,CAAc+B,GAAd,EAAd;AACA;;AAEJ,eAAK,IAAL;AACItC,YAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBsB,4BAArB,CAAZ;AACA8G,YAAAA,OAAO,CAACG,KAAR,CAAciB,IAAd,CAAmBpB,OAAO,CAACC,GAA3B;AACAD,YAAAA,OAAO,CAACC,GAAR,GAActJ,SAAS,CAACuE,UAAV,CAAqBO,iBAAnC;AACA;AAEA;;AACJ,eAAK,IAAL;AACI,gBAAIuF,WAAW,KAAK,EAAEnF,CAAlB,IAAuBY,KAAK,CAACZ,CAAD,CAAL,KAAa,IAAxC,EAA8C;AAC1C+D,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBkD,SAArB,CAAZ;AACA;AACH;;AAED;;AAEJ,eAAK,GAAL;AACA,eAAK,IAAL;AACI8E,YAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBM,OAArB,CAAZ;AAEA8H,YAAAA,OAAO,CAACG,KAAR,CAAciB,IAAd,CAAmBpB,OAAO,CAACC,GAA3B;AACAD,YAAAA,OAAO,CAACC,GAAR,GAActJ,SAAS,CAACuE,UAAV,CAAqBK,UAAnC;AACA6E,YAAAA,SAAS,GAAGa,KAAZ;AACA;AAEA;;AACJ;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAJ,YAAAA,QAAQ,GAAGI,KAAK,CAAClF,WAAN,CAAkB,CAAlB,CAAX,CAbJ,CAeI;;AACA,gBAAK8E,QAAQ,KAAK,GAAb,IAAoBlK,SAAS,CAACuF,UAAV,CAAqB2E,QAArB,CAArB,IAAwDA,QAAQ,KAAK,CAArE,IAA0EI,KAAK,KAAK,GAAxF,EAA6F;AACzF;AACArB,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoB6B,iBAArB,CAAZ;AACA;AACH,aAJD,MAKK,IAAI9C,SAAS,CAACsF,UAAV,CAAqB4E,QAArB,KAAkCA,QAAQ,KAAK,GAAnD,EAAwD;AACzDjB,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBsB,4BAArB,CAAZ;AACH;;AAEDmH,YAAAA,SAAS,CAAChF,OAAV,IAAqB4F,KAArB;AACAZ,YAAAA,SAAS,CAACjF,MAAV,IAAoB6F,KAApB;AACAV,YAAAA,QAAQ,CAACE,OAAT,CAAiBC,YAAjB,KAAkCO,KAAlC;AACAN,YAAAA,aAAa,IAAIU,MAAM,CAACC,UAAP,CAAkBL,KAAlB,EAAyB,MAAzB,CAAjB;AApLR;;AAuLA;AAEA;;AACJ,WAAKtK,SAAS,CAACuE,UAAV,CAAqBM,mBAA1B;AACI;AACA;AACA;AACA;AACA;AACA;AACA,gBAAQyF,KAAR;AACI;AACA,eAAK,IAAL;AACIjB,YAAAA,OAAO,CAACG,KAAR,CAAciB,IAAd,CAAmBpB,OAAO,CAACC,GAA3B;AACAD,YAAAA,OAAO,CAACC,GAAR,GAActJ,SAAS,CAACuE,UAAV,CAAqBO,iBAAnC;AACA;AAEA;;AACJ,eAAK,IAAL;AACI,gBAAIuF,WAAW,KAAK,EAAEnF,CAAlB,IAAuBY,KAAK,CAACZ,CAAD,CAAL,KAAa,IAAxC,EAA8C;AAC1C;AACA+D,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBkD,SAArB,CAAZ;AACA;AACH;;AAED;;AAEJ,eAAK,IAAL;AACI;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEAuF,YAAAA,SAAS,CAACC,KAAV,IAAmB,GAAnB;AACAC,YAAAA,QAAQ,CAACC,MAAT,CAAgBE,YAAhB,KAAiC,GAAjC;AACAC,YAAAA,aAAa,IAAIU,MAAM,CAACC,UAAP,CAAkBL,KAAlB,EAAyB,MAAzB,CAAjB;AAEArB,YAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBM,OAArB,CAAZ;AACA8H,YAAAA,OAAO,CAACG,KAAR,CAAciB,IAAd,CAAmBpB,OAAO,CAACC,GAA3B;AACAD,YAAAA,OAAO,CAACC,GAAR,GAActJ,SAAS,CAACuE,UAAV,CAAqBK,UAAnC;AACA6E,YAAAA,SAAS,GAAGa,KAAZ;AACA;AAEA;;AACJ,eAAK,GAAL;AACIZ,YAAAA,SAAS,CAACC,KAAV,IAAmBW,KAAnB;AACAV,YAAAA,QAAQ,CAACC,MAAT,CAAgBE,YAAhB,KAAiCO,KAAjC;AACAN,YAAAA,aAAa,IAAIU,MAAM,CAACC,UAAP,CAAkBL,KAAlB,EAAyB,MAAzB,CAAjB;AACAjB,YAAAA,OAAO,CAACE,IAAR,GAAeF,OAAO,CAACC,GAAvB;AACAD,YAAAA,OAAO,CAACC,GAAR,GAAcD,OAAO,CAACG,KAAR,CAAc+B,GAAd,EAAd;AACA;AAEA;;AACJ;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACArB,YAAAA,QAAQ,GAAGI,KAAK,CAAClF,WAAN,CAAkB,CAAlB,CAAX;;AAEA,gBAAK8E,QAAQ,KAAK,GAAb,IAAoBlK,SAAS,CAACuF,UAAV,CAAqB2E,QAArB,CAArB,IAAwDA,QAAQ,KAAK,CAArE,IAA0EA,QAAQ,KAAK,EAA3F,EAA+F;AAC3FjB,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBsC,iBAArB,CAAZ;AACH,aAFD,MAGK,IAAIvD,SAAS,CAACsF,UAAV,CAAqB4E,QAArB,KAAkCA,QAAQ,KAAK,GAAnD,EAAwD;AACzDjB,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBU,eAArB,CAAZ;AACH;;AAED+H,YAAAA,SAAS,CAACC,KAAV,IAAmBW,KAAnB;AACAV,YAAAA,QAAQ,CAACC,MAAT,CAAgBE,YAAhB,KAAiCO,KAAjC;AACAN,YAAAA,aAAa,IAAIU,MAAM,CAACC,UAAP,CAAkBL,KAAlB,EAAyB,MAAzB,CAAjB;AAzER,SAPJ,CAmFI;AACA;AACA;AACA;AACA;;;AAEA;AACA;;AACJ,WAAKtK,SAAS,CAACuE,UAAV,CAAqBO,iBAA1B;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAoF,QAAAA,QAAQ,GAAGI,KAAK,CAAClF,WAAN,CAAkB,CAAlB,CAAX;;AAEA,YAAI8E,QAAQ,KAAK,GAAb,IAAqBlK,SAAS,CAACuF,UAAV,CAAqB2E,QAArB,CAAzB,EAAyD;AACrD;AACAjB,UAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBoC,iBAArB,CAAZ;AACH,SAHD,MAIK,IAAK6G,QAAQ,GAAG,EAAX,IAAiBA,QAAQ,KAAK,CAA/B,IAAqCA,QAAQ,KAAK,GAAtD,EAA2D;AAC5D;AACAjB,UAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBW,YAArB,CAAZ;AACH,SAzBL,CA2BI;AACA;AACA;;;AAEAyH,QAAAA,OAAO,CAACE,IAAR,GAAeF,OAAO,CAACC,GAAvB,CA/BJ,CAgCI;;AACAD,QAAAA,OAAO,CAACC,GAAR,GAAcD,OAAO,CAACG,KAAR,CAAc+B,GAAd,EAAd;AACA,cAAMC,WAAW,GAAG,OAAOlB,KAA3B;;AAEA,gBAAQjB,OAAO,CAACC,GAAhB;AACI,eAAKtJ,SAAS,CAACuE,UAAV,CAAqBI,cAA1B;AACI;;AAEJ,eAAK3E,SAAS,CAACuE,UAAV,CAAqBM,mBAA1B;AACI6E,YAAAA,SAAS,CAACC,KAAV,IAAmB6B,WAAnB;AACA5B,YAAAA,QAAQ,CAACC,MAAT,CAAgBE,YAAhB,KAAiCyB,WAAjC,CAFJ,CAII;;AACAxB,YAAAA,aAAa,IAAI,CAAjB;AACA;;AAEJ,eAAKhK,SAAS,CAACuE,UAAV,CAAqBG,OAA1B;AACIgF,YAAAA,SAAS,CAACjF,MAAV,IAAoB+G,WAApB;AACA5B,YAAAA,QAAQ,CAACE,OAAT,CAAiBC,YAAjB,KAAkCyB,WAAlC,CAFJ,CAII;;AACAxB,YAAAA,aAAa,IAAI,CAAjB;AACA;AAEA;;AACJ;AACI,kBAAM,IAAIY,KAAJ,CAAU,sDAAsDvB,OAAO,CAACC,GAAxE,CAAN;AACA;AAvBR;;AA0BA;AAEA;;AACJ,WAAKtJ,SAAS,CAACuE,UAAV,CAAqBI,cAA1B;AACI;AACA;AACA;AACA;AACA,gBAAQ2F,KAAR;AACI;AACA,eAAK,GAAL;AACI;AACAjB,YAAAA,OAAO,CAACG,KAAR,CAAciB,IAAd,CAAmBpB,OAAO,CAACC,GAA3B;AACAD,YAAAA,OAAO,CAACC,GAAR,GAActJ,SAAS,CAACuE,UAAV,CAAqBI,cAAnC;AACA;AAEA;;AACJ,eAAK,GAAL;AACI0E,YAAAA,OAAO,CAACE,IAAR,GAAeF,OAAO,CAACC,GAAvB;AACAD,YAAAA,OAAO,CAACC,GAAR,GAAcD,OAAO,CAACG,KAAR,CAAc+B,GAAd,EAAd;AACA;AAEA;;AACJ,eAAK,IAAL;AACIlC,YAAAA,OAAO,CAACG,KAAR,CAAciB,IAAd,CAAmBpB,OAAO,CAACC,GAA3B;AACAD,YAAAA,OAAO,CAACC,GAAR,GAActJ,SAAS,CAACuE,UAAV,CAAqBO,iBAAnC;AACA;AAEA;;AACJ,eAAK,IAAL;AACI,gBAAIuF,WAAW,KAAK,EAAEnF,CAAlB,IAAuBY,KAAK,CAACZ,CAAD,CAAL,KAAa,IAAxC,EAA8C;AAC1C;AACA+D,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBkD,SAArB,CAAZ;AACA;AACH;;AAED;;AAEJ,eAAK,GAAL;AACA,eAAK,IAAL;AACI8E,YAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBM,OAArB,CAAZ;AAEA8H,YAAAA,OAAO,CAACG,KAAR,CAAciB,IAAd,CAAmBpB,OAAO,CAACC,GAA3B;AACAD,YAAAA,OAAO,CAACC,GAAR,GAActJ,SAAS,CAACuE,UAAV,CAAqBK,UAAnC;AACA6E,YAAAA,SAAS,GAAGa,KAAZ;AACA;AAEA;;AACJ;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAJ,YAAAA,QAAQ,GAAGI,KAAK,CAAClF,WAAN,CAAkB,CAAlB,CAAX;;AAEA,gBAAI8E,QAAQ,KAAK,CAAb,IAAkBA,QAAQ,KAAK,EAA/B,IAAsCA,QAAQ,KAAK,GAAb,IAAoBlK,SAAS,CAACuF,UAAV,CAAqB2E,QAArB,CAA9D,EAA+F;AAC3F;AACAjB,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBuC,iBAArB,CAAZ;AACA;AACH,aAJD,MAKK,IAAIxD,SAAS,CAACsF,UAAV,CAAqB4E,QAArB,KAAkCA,QAAQ,KAAK,GAAnD,EAAwD;AACzDjB,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBa,eAArB,CAAZ;AACH;;AA/DT;;AAkEA;AAEA;;AACJ,WAAK9B,SAAS,CAACuE,UAAV,CAAqBK,UAA1B;AACI;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,YAAI6E,SAAS,KAAK,IAAlB,EAAwB;AACpB,cAAIa,KAAK,KAAK,IAAd,EAAoB;AAChB;AACArB,YAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBgD,YAArB,CAAZ;AACA;AACH;;AAED,cAAI,EAAEgG,SAAF,GAAc,CAAlB,EAAqB;AACjB;AACAhB,YAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBS,aAArB,CAAZ;AACH,WAHD,MAIK;AACDuI,YAAAA,SAAS,GAAG,CAAZ;AACH;AACJ;;AAED,gBAAQK,KAAR;AACI,eAAK,IAAL;AACI,gBAAID,WAAW,KAAK,EAAEnF,CAAlB,IAAuBY,KAAK,CAACZ,CAAD,CAAL,KAAa,IAAxC,EAA8C;AAC1C;AACA+D,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBkD,SAArB,CAAZ;AACH;;AAED;;AAEJ,eAAK,GAAL;AACA,eAAK,IAAL;AACI;;AAEJ;AACI,gBAAIsF,SAAS,KAAK,IAAlB,EAAwB;AACpB;AACAR,cAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBiD,aAArB,CAAZ;AACH;;AAED+F,YAAAA,SAAS,GAAG,CAAZ,CANJ,CAQI;;AACAZ,YAAAA,OAAO,CAACE,IAAR,GAAeF,OAAO,CAACC,GAAvB;AACAD,YAAAA,OAAO,CAACC,GAAR,GAAcD,OAAO,CAACG,KAAR,CAAc+B,GAAd,EAAd,CAVJ,CAYI;;AACA,cAAErG,CAAF;AA1BR;;AA6BAuE,QAAAA,SAAS,GAAGa,KAAZ;AACA;AAEA;AACA;;AACJ;AACI,cAAM,IAAIM,KAAJ,CAAU,sBAAsBvB,OAAO,CAACC,GAAxC,CAAN;AACA;AAr4BR,KAJgD,CA04B9C;;;AAEF,QAAIN,SAAS,GAAGhJ,SAAS,CAACS,UAAV,CAAqBM,OAArC,EAA8C;AAC1C;AACA;AACH;AACJ,GA9/BuE,CA8/BtE;AAEF;;;AACA,MAAIiI,SAAS,GAAGhJ,SAAS,CAACS,UAAV,CAAqBM,OAArC,EAA8C;AAC1C,UAAM8J,cAAc,GAAGhL,QAAQ,CAAC2H,OAAT,CAAiBkC,SAAS,CAACjF,MAA3B,EAAmCU,MAA1D,CAD0C,CAE1C;;AACA,QAAIkE,OAAO,CAACC,GAAR,KAAgBtJ,SAAS,CAACuE,UAAV,CAAqBM,mBAAzC,EAA8D;AAC1DoE,MAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoB6C,uBAArB,CAAZ;AACH,KAFD,MAGK,IAAIuF,OAAO,CAACC,GAAR,KAAgBtJ,SAAS,CAACuE,UAAV,CAAqBO,iBAAzC,EAA4D;AAC7DmE,MAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBwC,eAArB,CAAZ;AACH,KAFI,MAGA,IAAI4F,OAAO,CAACC,GAAR,KAAgBtJ,SAAS,CAACuE,UAAV,CAAqBI,cAAzC,EAAyD;AAC1DsE,MAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoB8C,kBAArB,CAAZ;AACH,KAFI,MAGA,IAAIsF,OAAO,CAACC,GAAR,KAAgBtJ,SAAS,CAACuE,UAAV,CAAqBG,OAAzC,EAAkD;AACnDuE,MAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoB+C,wBAArB,CAAZ;AACH,KAFI,MAGA,IAAIsG,KAAK,KAAK,IAAd,EAAoB;AACrBrB,MAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBiD,aAArB,CAAZ;AACH,KAFI,MAGA,IAAIwF,SAAS,CAACjF,MAAV,CAAiBU,MAAjB,KAA4B,CAAhC,EAAmC;AACpC8D,MAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoB+B,WAArB,CAAZ;AACH,KAFI,MAGA,IAAIgH,aAAa,KAAK,CAAtB,EAAyB;AAC1Bf,MAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoB0C,SAArB,CAAZ;AACH,KAFI,MAGA,IAAIwG,UAAJ,EAAgB;AACjBlB,MAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoB4C,kBAArB,CAAZ;AACH,KAFI,CAIL;AAJK,SAKA,IAAIgH,cAAc,GAAG,GAArB,EAA0B;AAC3B;AACA;AACA5B,QAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBmB,oBAArB,CAAZ;AACH,OAJI,MAKA,IAAIsI,MAAM,CAACC,UAAP,CAAkBjB,SAAS,CAACC,KAA5B,EAAmC,MAAnC,IAA6CkB,cAA7C;AAA8D;AAAU,OAAxE,GAA4E,GAAhF,EAAqF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5B,QAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBiB,cAArB,CAAZ;AACH,OAjBI,MAkBA,IAAI8H,aAAa,GAAG,EAApB,EAAwB;AACzB;AACA;AACAf,QAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBoB,mBAArB,CAAZ;AACH,OAJI,MAKA,IAAI2F,OAAO,CAACc,cAAR,IAA0Bc,QAAQ,CAACE,OAAT,CAAiB3E,MAAjB,GAA0B6C,OAAO,CAACc,cAA5D,KAA+Ec,QAAQ,CAACE,OAAT,CAAiB3E,MAAjB,KAA4B,CAA5B,IAAiCyE,QAAQ,CAACE,OAAT,CAAiB,CAAjB,EAAoB,CAApB,MAA2B,GAA3I,CAAJ,EAAqJ;AACtJb,QAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBoD,iBAArB,CAAZ;AACH,OAFI,MAGA,IAAIrE,SAAS,CAACoI,wBAAV,CAAmCwB,QAAQ,CAACE,OAA5C,CAAJ,EAA0D;AAC3Db,QAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBqD,wBAArB,CAAZ;AACH,OAFI,MAGA,IAAI0D,OAAO,CAACG,YAAR,IAAwBH,OAAO,CAACE,YAApC,EAAkD;AACnD,cAAMH,OAAO,GAAG6B,QAAQ,CAACE,OAAT,CAAiBC,YAAjB,CAAhB;;AAEA,YAAI,CAAC/J,SAAS,CAAC8H,WAAV,CAAsBC,OAAtB,EAA+BC,OAA/B,CAAL,EAA8C;AAC1CiB,UAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBmD,aAArB,CAAZ;AACH;AACJ;AACJ,GAvkCuE,CAukCtE;AAEF;;;AACA,MAAI4E,SAAS,GAAGhJ,SAAS,CAACS,UAAV,CAAqBE,OAArC,EAA8C;AAC1C;AACA,UAAM0E,IAAI,GAAGuE,QAAQ,CAACE,OAAT,CAAiBC,YAAjB,EAA+B3E,WAA/B,CAA2C,CAA3C,CAAb;;AAEA,QAAIC,IAAI,IAAI,EAAZ,EAAgB;AACZ4D,MAAAA,YAAY,CAACjJ,SAAS,CAACiB,SAAV,CAAoBE,iBAArB,CAAZ;AACH;AACJ;;AAED,MAAI6H,SAAS,GAAGJ,SAAhB,EAA2B;AACvBI,IAAAA,SAAS,GAAGhJ,SAAS,CAACiB,SAAV,CAAoBP,KAAhC;AACH;;AAED,QAAM+K,YAAY,GAAG9C,QAAQ,GAAGK,SAAH,GAAeA,SAAS,GAAGhJ,SAAS,CAACO,gBAAlE,CAvlCwE,CAylCxE;;AACA,MAAIkI,QAAJ,EAAc;AACVA,IAAAA,QAAQ,CAACgD,YAAD,CAAR;AACH,GA5lCuE,CA6lCxE;;;AAEA,SAAOA,YAAP;AACH,CAhmCD;;AAmmCAlD,OAAO,CAACtH,SAAR,GAAoBjB,SAAS,CAACwI,QAAV,CAAmBvH,SAAnB,GAAgC,YAAY;AAE5D,QAAMyK,IAAI,GAAG,EAAb;AACA,QAAMrE,IAAI,GAAGnH,MAAM,CAACmH,IAAP,CAAYrH,SAAS,CAACiB,SAAtB,CAAb;;AACA,OAAK,IAAIiE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmC,IAAI,CAAClC,MAAzB,EAAiC,EAAED,CAAnC,EAAsC;AAClC,UAAMyG,GAAG,GAAGtE,IAAI,CAACnC,CAAD,CAAhB;AACAwG,IAAAA,IAAI,CAACC,GAAD,CAAJ,GAAY3L,SAAS,CAACiB,SAAV,CAAoB0K,GAApB,CAAZ;AACH;;AAED,SAAOD,IAAP;AACH,CAVkD,EAAnD;;AAaAnD,OAAO,CAAC3C,SAAR,GAAoB5F,SAAS,CAAC4F,SAA9B","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Punycode = require('punycode');\nconst Util = require('util');\n\n// Declare internals\n\nconst internals = {\n    hasOwn: Object.prototype.hasOwnProperty,\n    indexOf: Array.prototype.indexOf,\n    defaultThreshold: 16,\n    maxIPv6Groups: 8,\n\n    categories: {\n        valid: 1,\n        dnsWarn: 7,\n        rfc5321: 15,\n        cfws: 31,\n        deprecated: 63,\n        rfc5322: 127,\n        error: 255\n    },\n\n    diagnoses: {\n\n        // Address is valid\n\n        valid: 0,\n\n        // Address is valid for SMTP but has unusual elements\n\n        rfc5321TLD: 9,\n        rfc5321TLDNumeric: 10,\n        rfc5321QuotedString: 11,\n        rfc5321AddressLiteral: 12,\n\n        // Address is valid for message, but must be modified for envelope\n\n        cfwsComment: 17,\n        cfwsFWS: 18,\n\n        // Address contains non-ASCII when the allowUnicode option is false\n        // Has to be > internals.defaultThreshold so that it's rejected\n        // without an explicit errorLevel:\n        undesiredNonAscii: 25,\n\n        // Address contains deprecated elements, but may still be valid in some contexts\n\n        deprecatedLocalPart: 33,\n        deprecatedFWS: 34,\n        deprecatedQTEXT: 35,\n        deprecatedQP: 36,\n        deprecatedComment: 37,\n        deprecatedCTEXT: 38,\n        deprecatedIPv6: 39,\n        deprecatedCFWSNearAt: 49,\n\n        // Address is only valid according to broad definition in RFC 5322, but is otherwise invalid\n\n        rfc5322Domain: 65,\n        rfc5322TooLong: 66,\n        rfc5322LocalTooLong: 67,\n        rfc5322DomainTooLong: 68,\n        rfc5322LabelTooLong: 69,\n        rfc5322DomainLiteral: 70,\n        rfc5322DomainLiteralOBSDText: 71,\n        rfc5322IPv6GroupCount: 72,\n        rfc5322IPv62x2xColon: 73,\n        rfc5322IPv6BadCharacter: 74,\n        rfc5322IPv6MaxGroups: 75,\n        rfc5322IPv6ColonStart: 76,\n        rfc5322IPv6ColonEnd: 77,\n\n        // Address is invalid for any purpose\n\n        errExpectingDTEXT: 129,\n        errNoLocalPart: 130,\n        errNoDomain: 131,\n        errConsecutiveDots: 132,\n        errATEXTAfterCFWS: 133,\n        errATEXTAfterQS: 134,\n        errATEXTAfterDomainLiteral: 135,\n        errExpectingQPair: 136,\n        errExpectingATEXT: 137,\n        errExpectingQTEXT: 138,\n        errExpectingCTEXT: 139,\n        errBackslashEnd: 140,\n        errDotStart: 141,\n        errDotEnd: 142,\n        errDomainHyphenStart: 143,\n        errDomainHyphenEnd: 144,\n        errUnclosedQuotedString: 145,\n        errUnclosedComment: 146,\n        errUnclosedDomainLiteral: 147,\n        errFWSCRLFx2: 148,\n        errFWSCRLFEnd: 149,\n        errCRNoLF: 150,\n        errUnknownTLD: 160,\n        errDomainTooShort: 161,\n        errDotAfterDomainLiteral: 162\n    },\n\n    components: {\n        localpart: 0,\n        domain: 1,\n        literal: 2,\n        contextComment: 3,\n        contextFWS: 4,\n        contextQuotedString: 5,\n        contextQuotedPair: 6\n    }\n};\n\n\ninternals.specials = function () {\n\n    const specials = '()<>[]:;@\\\\,.\"';        // US-ASCII visible characters not valid for atext (http://tools.ietf.org/html/rfc5322#section-3.2.3)\n    const lookup = new Array(0x100);\n    lookup.fill(false);\n\n    for (let i = 0; i < specials.length; ++i) {\n        lookup[specials.codePointAt(i)] = true;\n    }\n\n    return function (code) {\n\n        return lookup[code];\n    };\n}();\n\ninternals.c0Controls = function () {\n\n    const lookup = new Array(0x100);\n    lookup.fill(false);\n\n    // add C0 control characters\n\n    for (let i = 0; i < 33; ++i) {\n        lookup[i] = true;\n    }\n\n    return function (code) {\n\n        return lookup[code];\n    };\n}();\n\ninternals.c1Controls = function () {\n\n    const lookup = new Array(0x100);\n    lookup.fill(false);\n\n    // add C1 control characters\n\n    for (let i = 127; i < 160; ++i) {\n        lookup[i] = true;\n    }\n\n    return function (code) {\n\n        return lookup[code];\n    };\n}();\n\ninternals.regex = {\n    ipV4: /\\b(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n    ipV6: /^[a-fA-F\\d]{0,4}$/\n};\n\ninternals.normalizeSupportsNul = '\\0'.normalize('NFC') === '\\0';\n\n\n// $lab:coverage:off$\ninternals.nulNormalize = function (email) {\n\n    return email.split('\\0').map((part) => part.normalize('NFC')).join('\\0');\n};\n// $lab:coverage:on$\n\n\ninternals.normalize = function (email) {\n\n    return email.normalize('NFC');\n};\n\n\n// $lab:coverage:off$\nif (!internals.normalizeSupportsNul) {\n    internals.normalize = function (email) {\n\n        if (email.indexOf('\\0') >= 0) {\n            return internals.nulNormalize(email);\n        }\n\n        return email.normalize('NFC');\n    };\n}\n// $lab:coverage:on$\n\n\ninternals.checkIpV6 = function (items) {\n\n    return items.every((value) => internals.regex.ipV6.test(value));\n};\n\n\ninternals.isIterable = Array.isArray;\n\n\n/* $lab:coverage:off$ */\nif (typeof Symbol !== 'undefined') {\n    internals.isIterable = (value) => Array.isArray(value) || (!!value && typeof value === 'object' && typeof value[Symbol.iterator] === 'function');\n}\n/* $lab:coverage:on$ */\n\n\n// Node 10 introduced isSet and isMap, which are useful for cross-context type\n// checking.\n// $lab:coverage:off$\ninternals._isSet = (value) => value instanceof Set;\ninternals._isMap = (value) => value instanceof Map;\ninternals.isSet = Util.types && Util.types.isSet || internals._isSet;\ninternals.isMap = Util.types && Util.types.isMap || internals._isMap;\n// $lab:coverage:on$\n\n\n/**\n * Normalize the given lookup \"table\" to an iterator. Outputs items in arrays\n * and sets, keys from maps (regardless of the corresponding value), and own\n * enumerable keys from all other objects (intended to be plain objects).\n *\n * @param {*} table The table to convert.\n * @returns {Iterable<*>} The converted table.\n */\ninternals.normalizeTable = function (table) {\n\n    if (internals.isSet(table) || Array.isArray(table)) {\n        return table;\n    }\n\n    if (internals.isMap(table)) {\n        return table.keys();\n    }\n\n    return Object.keys(table);\n};\n\n\n/**\n * Convert the given domain atom to its canonical form using Nameprep and string\n * lowercasing. Domain atoms that are all-ASCII will not undergo any changes via\n * Nameprep, and domain atoms that have already been canonicalized will not be\n * altered.\n *\n * @param {string} atom The atom to canonicalize.\n * @returns {string} The canonicalized atom.\n */\ninternals.canonicalizeAtom = function (atom) {\n\n    return Punycode.toASCII(atom).toLowerCase();\n};\n\n\n/**\n * Check whether any of the values in the given iterable, when passed through\n * the iteratee function, are equal to the given value.\n *\n * @param {Iterable<*>} iterable The iterable to check.\n * @param {function(*): *} iteratee The iteratee that receives each item from\n *   the iterable.\n * @param {*} value The reference value.\n * @returns {boolean} Whether the given value matches any of the items in the\n *   iterable per the iteratee.\n */\ninternals.includesMapped = function (iterable, iteratee, value) {\n\n    for (const item of iterable) {\n        if (value === iteratee(item)) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n\n/**\n * Check whether the given top-level domain atom is valid based on the\n * configured blacklist/whitelist.\n *\n * @param {string} tldAtom The atom to check.\n * @param {Object} options\n *   {*} tldBlacklist The set of domains to consider invalid.\n *   {*} tldWhitelist The set of domains to consider valid.\n * @returns {boolean} Whether the given domain atom is valid per the blacklist/\n *   whitelist.\n */\ninternals.validDomain = function (tldAtom, options) {\n\n    // Nameprep handles case-sensitive unicode stuff, but doesn't touch\n    // uppercase ASCII characters.\n    const canonicalTldAtom = internals.canonicalizeAtom(tldAtom);\n\n    if (options.tldBlacklist) {\n        return !internals.includesMapped(\n            internals.normalizeTable(options.tldBlacklist),\n            internals.canonicalizeAtom, canonicalTldAtom);\n    }\n\n    return internals.includesMapped(\n        internals.normalizeTable(options.tldWhitelist),\n        internals.canonicalizeAtom, canonicalTldAtom);\n};\n\n\n/**\n * Check whether the domain atoms has an address literal part followed by a\n * normal domain atom part. For example, [127.0.0.1].com.\n *\n * @param {string[]} domainAtoms The parsed domain atoms.\n * @returns {boolean} Whether there exists both a normal domain atom and an\n *   address literal.\n */\ninternals.hasDomainLiteralThenAtom = function (domainAtoms) {\n\n    let hasDomainLiteral = false;\n    for (let i = 0; i < domainAtoms.length; ++i) {\n        if (domainAtoms[i][0] === '[') {\n            hasDomainLiteral = true;\n        }\n        else if (hasDomainLiteral) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n\n/**\n * Check that an email address conforms to RFCs 5321, 5322, 6530 and others\n *\n * We distinguish clearly between a Mailbox as defined by RFC 5321 and an\n * addr-spec as defined by RFC 5322. Depending on the context, either can be\n * regarded as a valid email address. The RFC 5321 Mailbox specification is\n * more restrictive (comments, white space and obsolete forms are not allowed).\n *\n * @param {string} email The email address to check. See README for specifics.\n * @param {Object} options The (optional) options:\n *   {*} errorLevel Determines the boundary between valid and invalid\n *     addresses.\n *   {*} tldBlacklist The set of domains to consider invalid.\n *   {*} tldWhitelist The set of domains to consider valid.\n *   {*} allowUnicode Whether to allow non-ASCII characters, defaults to true.\n *   {*} minDomainAtoms The minimum number of domain atoms which must be present\n *     for the address to be valid.\n * @param {function(number|boolean)} callback The (optional) callback handler.\n * @return {*}\n */\n\nexports.validate = internals.validate = function (email, options, callback) {\n\n    options = options || {};\n\n    if (typeof email !== 'string') {\n        throw new TypeError('expected string email');\n    }\n\n    email = internals.normalize(email);\n\n    // The callback function is deprecated.\n    // $lab:coverage:off$\n    if (typeof options === 'function') {\n        callback = options;\n        options = {};\n    }\n\n    if (typeof callback !== 'function') {\n        callback = null;\n    }\n    // $lab:coverage:on$\n\n    let diagnose;\n    let threshold;\n\n    if (typeof options.errorLevel === 'number') {\n        diagnose = true;\n        threshold = options.errorLevel;\n    }\n    else {\n        diagnose = !!options.errorLevel;\n        threshold = internals.diagnoses.valid;\n    }\n\n    if (options.tldWhitelist) {\n        if (typeof options.tldWhitelist === 'string') {\n            options.tldWhitelist = [options.tldWhitelist];\n        }\n        else if (typeof options.tldWhitelist !== 'object') {\n            throw new TypeError('expected array or object tldWhitelist');\n        }\n    }\n\n    if (options.tldBlacklist) {\n        if (typeof options.tldBlacklist === 'string') {\n            options.tldBlacklist = [options.tldBlacklist];\n        }\n        else if (typeof options.tldBlacklist !== 'object') {\n            throw new TypeError('expected array or object tldBlacklist');\n        }\n    }\n\n    if (options.minDomainAtoms && (options.minDomainAtoms !== ((+options.minDomainAtoms) | 0) || options.minDomainAtoms < 0)) {\n        throw new TypeError('expected positive integer minDomainAtoms');\n    }\n\n    // Normalize the set of excluded diagnoses.\n    if (options.excludeDiagnoses) {\n        if (!internals.isIterable(options.excludeDiagnoses)) {\n            throw new TypeError('expected iterable excludeDiagnoses');\n        }\n\n        // This won't catch cross-realm Sets pre-Node 10, but it will cast the\n        // value to an in-realm Set representation.\n        if (!internals.isSet(options.excludeDiagnoses)) {\n            options.excludeDiagnoses = new Set(options.excludeDiagnoses);\n        }\n    }\n\n    let maxResult = internals.diagnoses.valid;\n    const updateResult = (value) => {\n\n        if (value > maxResult && (!options.excludeDiagnoses || !options.excludeDiagnoses.has(value))) {\n            maxResult = value;\n        }\n    };\n\n    const allowUnicode = options.allowUnicode === undefined || !!options.allowUnicode;\n    if (!allowUnicode && /[^\\x00-\\x7f]/.test(email)) {\n        updateResult(internals.diagnoses.undesiredNonAscii);\n    }\n\n    const context = {\n        now: internals.components.localpart,\n        prev: internals.components.localpart,\n        stack: [internals.components.localpart]\n    };\n\n    let prevToken = '';\n\n    const parseData = {\n        local: '',\n        domain: ''\n    };\n    const atomData = {\n        locals: [''],\n        domains: ['']\n    };\n\n    let elementCount = 0;\n    let elementLength = 0;\n    let crlfCount = 0;\n    let charCode;\n\n    let hyphenFlag = false;\n    let assertEnd = false;\n\n    const emailLength = email.length;\n\n    let token;                                      // Token is used outside the loop, must declare similarly\n    for (let i = 0; i < emailLength; i += token.length) {\n        // Utilize codepoints to account for Unicode surrogate pairs\n        token = String.fromCodePoint(email.codePointAt(i));\n\n        switch (context.now) {\n            // Local-part\n            case internals.components.localpart:\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   local-part      =   dot-atom / quoted-string / obs-local-part\n                //\n                //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\n                //\n                //   dot-atom-text   =   1*atext *(\".\" 1*atext)\n                //\n                //   quoted-string   =   [CFWS]\n                //                       DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n                //                       [CFWS]\n                //\n                //   obs-local-part  =   word *(\".\" word)\n                //\n                //   word            =   atom / quoted-string\n                //\n                //   atom            =   [CFWS] 1*atext [CFWS]\n                switch (token) {\n                    // Comment\n                    case '(':\n                        if (elementLength === 0) {\n                            // Comments are OK at the beginning of an element\n                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsComment : internals.diagnoses.deprecatedComment);\n                        }\n                        else {\n                            updateResult(internals.diagnoses.cfwsComment);\n                            // Cannot start a comment in an element, should be end\n                            assertEnd = true;\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextComment;\n                        break;\n\n                        // Next dot-atom element\n                    case '.':\n                        if (elementLength === 0) {\n                            // Another dot, already?\n                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\n                        }\n                        else {\n                            // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\n                            if (assertEnd) {\n                                updateResult(internals.diagnoses.deprecatedLocalPart);\n                            }\n\n                            // CFWS & quoted strings are OK again now we're at the beginning of an element (although they are obsolete forms)\n                            assertEnd = false;\n                            elementLength = 0;\n                            ++elementCount;\n                            parseData.local += token;\n                            atomData.locals[elementCount] = '';\n                        }\n\n                        break;\n\n                        // Quoted string\n                    case '\"':\n                        if (elementLength === 0) {\n                            // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\n                            updateResult(elementCount === 0 ? internals.diagnoses.rfc5321QuotedString : internals.diagnoses.deprecatedLocalPart);\n\n                            parseData.local += token;\n                            atomData.locals[elementCount] += token;\n                            elementLength += Buffer.byteLength(token, 'utf8');\n\n                            // Quoted string must be the entire element\n                            assertEnd = true;\n                            context.stack.push(context.now);\n                            context.now = internals.components.contextQuotedString;\n                        }\n                        else {\n                            updateResult(internals.diagnoses.errExpectingATEXT);\n                        }\n\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        if (elementLength === 0) {\n                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsFWS : internals.diagnoses.deprecatedFWS);\n                        }\n                        else {\n                            // We can't start FWS in the middle of an element, better be end\n                            assertEnd = true;\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                    case '@':\n                        // At this point we should have a valid local-part\n                        // $lab:coverage:off$\n                        if (context.stack.length !== 1) {\n                            throw new Error('unexpected item on context stack');\n                        }\n                        // $lab:coverage:on$\n\n                        if (parseData.local.length === 0) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errNoLocalPart);\n                        }\n                        else if (elementLength === 0) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errDotEnd);\n                        }\n                        // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1 the maximum total length of a user name or other local-part is 64\n                        //    octets\n                        else if (Buffer.byteLength(parseData.local, 'utf8') > 64) {\n                            updateResult(internals.diagnoses.rfc5322LocalTooLong);\n                        }\n                        // http://tools.ietf.org/html/rfc5322#section-3.4.1 comments and folding white space SHOULD NOT be used around \"@\" in the\n                        //    addr-spec\n                        //\n                        // http://tools.ietf.org/html/rfc2119\n                        // 4. SHOULD NOT this phrase, or the phrase \"NOT RECOMMENDED\" mean that there may exist valid reasons in particular\n                        //    circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood\n                        //    and the case carefully weighed before implementing any behavior described with this label.\n                        else if (context.prev === internals.components.contextComment || context.prev === internals.components.contextFWS) {\n                            updateResult(internals.diagnoses.deprecatedCFWSNearAt);\n                        }\n\n                        // Clear everything down for the domain parsing\n                        context.now = internals.components.domain;\n                        context.stack[0] = internals.components.domain;\n                        elementCount = 0;\n                        elementLength = 0;\n                        assertEnd = false; // CFWS can only appear at the end of the element\n                        break;\n\n                        // ATEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\n                        //    atext = ALPHA / DIGIT / ; Printable US-ASCII\n                        //            \"!\" / \"#\" /     ;  characters not including\n                        //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\n                        //            \"&\" / \"'\" /\n                        //            \"*\" / \"+\" /\n                        //            \"-\" / \"/\" /\n                        //            \"=\" / \"?\" /\n                        //            \"^\" / \"_\" /\n                        //            \"`\" / \"{\" /\n                        //            \"|\" / \"}\" /\n                        //            \"~\"\n                        if (assertEnd) {\n                            // We have encountered atext where it is no longer valid\n                            switch (context.prev) {\n                                case internals.components.contextComment:\n                                case internals.components.contextFWS:\n                                    updateResult(internals.diagnoses.errATEXTAfterCFWS);\n                                    break;\n\n                                case internals.components.contextQuotedString:\n                                    updateResult(internals.diagnoses.errATEXTAfterQS);\n                                    break;\n\n                                    // $lab:coverage:off$\n                                default:\n                                    throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\n                                    // $lab:coverage:on$\n                            }\n                        }\n                        else {\n                            context.prev = context.now;\n                            charCode = token.codePointAt(0);\n\n                            // Especially if charCode == 10\n                            if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {\n\n                                // Fatal error\n                                updateResult(internals.diagnoses.errExpectingATEXT);\n                            }\n\n                            parseData.local += token;\n                            atomData.locals[elementCount] += token;\n                            elementLength += Buffer.byteLength(token, 'utf8');\n                        }\n                }\n\n                break;\n\n            case internals.components.domain:\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   domain          =   dot-atom / domain-literal / obs-domain\n                //\n                //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\n                //\n                //   dot-atom-text   =   1*atext *(\".\" 1*atext)\n                //\n                //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\n                //\n                //   dtext           =   %d33-90 /          ; Printable US-ASCII\n                //                       %d94-126 /         ;  characters not including\n                //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\n                //\n                //   obs-domain      =   atom *(\".\" atom)\n                //\n                //   atom            =   [CFWS] 1*atext [CFWS]\n\n                // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                //   Mailbox        = Local-part \"@\" ( Domain / address-literal )\n                //\n                //   Domain         = sub-domain *(\".\" sub-domain)\n                //\n                //   address-literal  = \"[\" ( IPv4-address-literal /\n                //                    IPv6-address-literal /\n                //                    General-address-literal ) \"]\"\n                //                    ; See Section 4.1.3\n\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //      Note: A liberal syntax for the domain portion of addr-spec is\n                //      given here.  However, the domain portion contains addressing\n                //      information specified by and used in other protocols (e.g.,\n                //      [RFC1034], [RFC1035], [RFC1123], [RFC5321]).  It is therefore\n                //      incumbent upon implementations to conform to the syntax of\n                //      addresses for the context in which they are used.\n                //\n                // is_email() author's note: it's not clear how to interpret this in\n                // he context of a general email address validator. The conclusion I\n                // have reached is this: \"addressing information\" must comply with\n                // RFC 5321 (and in turn RFC 1035), anything that is \"semantically\n                // invisible\" must comply only with RFC 5322.\n                switch (token) {\n                    // Comment\n                    case '(':\n                        if (elementLength === 0) {\n                            // Comments at the start of the domain are deprecated in the text, comments at the start of a subdomain are obs-domain\n                            // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedComment);\n                        }\n                        else {\n                            // We can't start a comment mid-element, better be at the end\n                            assertEnd = true;\n                            updateResult(internals.diagnoses.cfwsComment);\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextComment;\n                        break;\n\n                        // Next dot-atom element\n                    case '.':\n                        const punycodeLength = Punycode.toASCII(atomData.domains[elementCount]).length;\n                        if (elementLength === 0) {\n                            // Another dot, already? Fatal error.\n                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\n                        }\n                        else if (hyphenFlag) {\n                            // Previous subdomain ended in a hyphen. Fatal error.\n                            updateResult(internals.diagnoses.errDomainHyphenEnd);\n                        }\n                        else if (punycodeLength > 63) {\n                            // RFC 5890 specifies that domain labels that are encoded using the Punycode algorithm\n                            // must adhere to the <= 63 octet requirement.\n                            // This includes string prefixes from the Punycode algorithm.\n                            //\n                            // https://tools.ietf.org/html/rfc5890#section-2.3.2.1\n                            // labels          63 octets or less\n\n                            updateResult(internals.diagnoses.rfc5322LabelTooLong);\n                        }\n\n                        // CFWS is OK again now we're at the beginning of an element (although\n                        // it may be obsolete CFWS)\n                        assertEnd = false;\n                        elementLength = 0;\n                        ++elementCount;\n                        atomData.domains[elementCount] = '';\n                        parseData.domain += token;\n\n                        break;\n\n                        // Domain literal\n                    case '[':\n                        if (atomData.domains[elementCount].length === 0) {\n                            if (parseData.domain.length) {\n                                // Domain literal interspersed with domain refs.\n                                updateResult(internals.diagnoses.errDotAfterDomainLiteral);\n                            }\n\n                            assertEnd = true;\n                            elementLength += Buffer.byteLength(token, 'utf8');\n                            context.stack.push(context.now);\n                            context.now = internals.components.literal;\n                            parseData.domain += token;\n                            atomData.domains[elementCount] += token;\n                            parseData.literal = '';\n                        }\n                        else {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingATEXT);\n                        }\n\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        if (elementLength === 0) {\n                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedFWS);\n                        }\n                        else {\n                            // We can't start FWS in the middle of an element, so this better be the end\n                            updateResult(internals.diagnoses.cfwsFWS);\n                            assertEnd = true;\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // This must be ATEXT\n                    default:\n                        // RFC 5322 allows any atext...\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\n                        //    atext = ALPHA / DIGIT / ; Printable US-ASCII\n                        //            \"!\" / \"#\" /     ;  characters not including\n                        //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\n                        //            \"&\" / \"'\" /\n                        //            \"*\" / \"+\" /\n                        //            \"-\" / \"/\" /\n                        //            \"=\" / \"?\" /\n                        //            \"^\" / \"_\" /\n                        //            \"`\" / \"{\" /\n                        //            \"|\" / \"}\" /\n                        //            \"~\"\n\n                        // But RFC 5321 only allows letter-digit-hyphen to comply with DNS rules\n                        //   (RFCs 1034 & 1123)\n                        // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                        //   sub-domain     = Let-dig [Ldh-str]\n                        //\n                        //   Let-dig        = ALPHA / DIGIT\n                        //\n                        //   Ldh-str        = *( ALPHA / DIGIT / \"-\" ) Let-dig\n                        //\n                        if (assertEnd) {\n                            // We have encountered ATEXT where it is no longer valid\n                            switch (context.prev) {\n                                case internals.components.contextComment:\n                                case internals.components.contextFWS:\n                                    updateResult(internals.diagnoses.errATEXTAfterCFWS);\n                                    break;\n\n                                case internals.components.literal:\n                                    updateResult(internals.diagnoses.errATEXTAfterDomainLiteral);\n                                    break;\n\n                                    // $lab:coverage:off$\n                                default:\n                                    throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\n                                    // $lab:coverage:on$\n                            }\n                        }\n\n                        charCode = token.codePointAt(0);\n                        // Assume this token isn't a hyphen unless we discover it is\n                        hyphenFlag = false;\n\n                        if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingATEXT);\n                        }\n                        else if (token === '-') {\n                            if (elementLength === 0) {\n                                // Hyphens cannot be at the beginning of a subdomain, fatal error\n                                updateResult(internals.diagnoses.errDomainHyphenStart);\n                            }\n\n                            hyphenFlag = true;\n                        }\n                        // Check if it's a neither a number nor a latin/unicode letter\n                        else if (charCode < 48 || (charCode > 122 && charCode < 192) || (charCode > 57 && charCode < 65) || (charCode > 90 && charCode < 97)) {\n                            // This is not an RFC 5321 subdomain, but still OK by RFC 5322\n                            updateResult(internals.diagnoses.rfc5322Domain);\n                        }\n\n                        parseData.domain += token;\n                        atomData.domains[elementCount] += token;\n                        elementLength += Buffer.byteLength(token, 'utf8');\n                }\n\n                break;\n\n                // Domain literal\n            case internals.components.literal:\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\n                //\n                //   dtext           =   %d33-90 /          ; Printable US-ASCII\n                //                       %d94-126 /         ;  characters not including\n                //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\n                //\n                //   obs-dtext       =   obs-NO-WS-CTL / quoted-pair\n                switch (token) {\n                    // End of domain literal\n                    case ']':\n                        if (maxResult < internals.categories.deprecated) {\n                            // Could be a valid RFC 5321 address literal, so let's check\n\n                            // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                            //   address-literal  = \"[\" ( IPv4-address-literal /\n                            //                    IPv6-address-literal /\n                            //                    General-address-literal ) \"]\"\n                            //                    ; See Section 4.1.3\n                            //\n                            // http://tools.ietf.org/html/rfc5321#section-4.1.3\n                            //   IPv4-address-literal  = Snum 3(\".\"  Snum)\n                            //\n                            //   IPv6-address-literal  = \"IPv6:\" IPv6-addr\n                            //\n                            //   General-address-literal  = Standardized-tag \":\" 1*dcontent\n                            //\n                            //   Standardized-tag  = Ldh-str\n                            //                     ; Standardized-tag MUST be specified in a\n                            //                     ; Standards-Track RFC and registered with IANA\n                            //\n                            //   dcontent      = %d33-90 / ; Printable US-ASCII\n                            //                 %d94-126 ; excl. \"[\", \"\\\", \"]\"\n                            //\n                            //   Snum          = 1*3DIGIT\n                            //                 ; representing a decimal integer\n                            //                 ; value in the range 0 through 255\n                            //\n                            //   IPv6-addr     = IPv6-full / IPv6-comp / IPv6v4-full / IPv6v4-comp\n                            //\n                            //   IPv6-hex      = 1*4HEXDIG\n                            //\n                            //   IPv6-full     = IPv6-hex 7(\":\" IPv6-hex)\n                            //\n                            //   IPv6-comp     = [IPv6-hex *5(\":\" IPv6-hex)] \"::\"\n                            //                 [IPv6-hex *5(\":\" IPv6-hex)]\n                            //                 ; The \"::\" represents at least 2 16-bit groups of\n                            //                 ; zeros.  No more than 6 groups in addition to the\n                            //                 ; \"::\" may be present.\n                            //\n                            //   IPv6v4-full   = IPv6-hex 5(\":\" IPv6-hex) \":\" IPv4-address-literal\n                            //\n                            //   IPv6v4-comp   = [IPv6-hex *3(\":\" IPv6-hex)] \"::\"\n                            //                 [IPv6-hex *3(\":\" IPv6-hex) \":\"]\n                            //                 IPv4-address-literal\n                            //                 ; The \"::\" represents at least 2 16-bit groups of\n                            //                 ; zeros.  No more than 4 groups in addition to the\n                            //                 ; \"::\" and IPv4-address-literal may be present.\n\n                            let index = -1;\n                            let addressLiteral = parseData.literal;\n                            const matchesIP = internals.regex.ipV4.exec(addressLiteral);\n\n                            // Maybe extract IPv4 part from the end of the address-literal\n                            if (matchesIP) {\n                                index = matchesIP.index;\n                                if (index !== 0) {\n                                    // Convert IPv4 part to IPv6 format for futher testing\n                                    addressLiteral = addressLiteral.slice(0, index) + '0:0';\n                                }\n                            }\n\n                            if (index === 0) {\n                                // Nothing there except a valid IPv4 address, so...\n                                updateResult(internals.diagnoses.rfc5321AddressLiteral);\n                            }\n                            else if (addressLiteral.slice(0, 5).toLowerCase() !== 'ipv6:') {\n                                updateResult(internals.diagnoses.rfc5322DomainLiteral);\n                            }\n                            else {\n                                const match = addressLiteral.slice(5);\n                                let maxGroups = internals.maxIPv6Groups;\n                                const groups = match.split(':');\n                                index = match.indexOf('::');\n\n                                if (!~index) {\n                                    // Need exactly the right number of groups\n                                    if (groups.length !== maxGroups) {\n                                        updateResult(internals.diagnoses.rfc5322IPv6GroupCount);\n                                    }\n                                }\n                                else if (index !== match.lastIndexOf('::')) {\n                                    updateResult(internals.diagnoses.rfc5322IPv62x2xColon);\n                                }\n                                else {\n                                    if (index === 0 || index === match.length - 2) {\n                                        // RFC 4291 allows :: at the start or end of an address with 7 other groups in addition\n                                        ++maxGroups;\n                                    }\n\n                                    if (groups.length > maxGroups) {\n                                        updateResult(internals.diagnoses.rfc5322IPv6MaxGroups);\n                                    }\n                                    else if (groups.length === maxGroups) {\n                                        // Eliding a single \"::\"\n                                        updateResult(internals.diagnoses.deprecatedIPv6);\n                                    }\n                                }\n\n                                // IPv6 testing strategy\n                                if (match[0] === ':' && match[1] !== ':') {\n                                    updateResult(internals.diagnoses.rfc5322IPv6ColonStart);\n                                }\n                                else if (match[match.length - 1] === ':' && match[match.length - 2] !== ':') {\n                                    updateResult(internals.diagnoses.rfc5322IPv6ColonEnd);\n                                }\n                                else if (internals.checkIpV6(groups)) {\n                                    updateResult(internals.diagnoses.rfc5321AddressLiteral);\n                                }\n                                else {\n                                    updateResult(internals.diagnoses.rfc5322IPv6BadCharacter);\n                                }\n                            }\n                        }\n                        else {\n                            updateResult(internals.diagnoses.rfc5322DomainLiteral);\n                        }\n\n                        parseData.domain += token;\n                        atomData.domains[elementCount] += token;\n                        elementLength += Buffer.byteLength(token, 'utf8');\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n                        break;\n\n                    case '\\\\':\n                        updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextQuotedPair;\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        updateResult(internals.diagnoses.cfwsFWS);\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // DTEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                        //   dtext         =   %d33-90 /  ; Printable US-ASCII\n                        //                     %d94-126 / ;  characters not including\n                        //                     obs-dtext  ;  \"[\", \"]\", or \"\\\"\n                        //\n                        //   obs-dtext     =   obs-NO-WS-CTL / quoted-pair\n                        //\n                        //   obs-NO-WS-CTL =   %d1-8 /    ; US-ASCII control\n                        //                     %d11 /     ;  characters that do not\n                        //                     %d12 /     ;  include the carriage\n                        //                     %d14-31 /  ;  return, line feed, and\n                        //                     %d127      ;  white space characters\n                        charCode = token.codePointAt(0);\n\n                        // '\\r', '\\n', ' ', and '\\t' have already been parsed above\n                        if ((charCode !== 127 && internals.c1Controls(charCode)) || charCode === 0 || token === '[') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingDTEXT);\n                            break;\n                        }\n                        else if (internals.c0Controls(charCode) || charCode === 127) {\n                            updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\n                        }\n\n                        parseData.literal += token;\n                        parseData.domain += token;\n                        atomData.domains[elementCount] += token;\n                        elementLength += Buffer.byteLength(token, 'utf8');\n                }\n\n                break;\n\n                // Quoted string\n            case internals.components.contextQuotedString:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.4\n                //   quoted-string = [CFWS]\n                //                   DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n                //                   [CFWS]\n                //\n                //   qcontent      = qtext / quoted-pair\n                switch (token) {\n                    // Quoted pair\n                    case '\\\\':\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextQuotedPair;\n                        break;\n\n                        // Folding white space. Spaces are allowed as regular characters inside a quoted string - it's only FWS if we include '\\t' or '\\r\\n'\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case '\\t':\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.2\n                        //   Runs of FWS, comment, or CFWS that occur between lexical tokens in\n                        //   a structured header field are semantically interpreted as a single\n                        //   space character.\n\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.4\n                        //   the CRLF in any FWS/CFWS that appears within the quoted-string [is]\n                        //   semantically \"invisible\" and therefore not part of the\n                        //   quoted-string\n\n                        parseData.local += ' ';\n                        atomData.locals[elementCount] += ' ';\n                        elementLength += Buffer.byteLength(token, 'utf8');\n\n                        updateResult(internals.diagnoses.cfwsFWS);\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // End of quoted string\n                    case '\"':\n                        parseData.local += token;\n                        atomData.locals[elementCount] += token;\n                        elementLength += Buffer.byteLength(token, 'utf8');\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n                        break;\n\n                        // QTEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.4\n                        //   qtext          =   %d33 /             ; Printable US-ASCII\n                        //                      %d35-91 /          ;  characters not including\n                        //                      %d93-126 /         ;  \"\\\" or the quote character\n                        //                      obs-qtext\n                        //\n                        //   obs-qtext      =   obs-NO-WS-CTL\n                        //\n                        //   obs-NO-WS-CTL  =   %d1-8 /            ; US-ASCII control\n                        //                      %d11 /             ;  characters that do not\n                        //                      %d12 /             ;  include the carriage\n                        //                      %d14-31 /          ;  return, line feed, and\n                        //                      %d127              ;  white space characters\n                        charCode = token.codePointAt(0);\n\n                        if ((charCode !== 127 && internals.c1Controls(charCode)) || charCode === 0 || charCode === 10) {\n                            updateResult(internals.diagnoses.errExpectingQTEXT);\n                        }\n                        else if (internals.c0Controls(charCode) || charCode === 127) {\n                            updateResult(internals.diagnoses.deprecatedQTEXT);\n                        }\n\n                        parseData.local += token;\n                        atomData.locals[elementCount] += token;\n                        elementLength += Buffer.byteLength(token, 'utf8');\n                }\n\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   If the string can be represented as a dot-atom (that is, it contains\n                //   no characters other than atext characters or \".\" surrounded by atext\n                //   characters), then the dot-atom form SHOULD be used and the quoted-\n                //   string form SHOULD NOT be used.\n\n                break;\n                // Quoted pair\n            case internals.components.contextQuotedPair:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.1\n                //   quoted-pair     =   (\"\\\" (VCHAR / WSP)) / obs-qp\n                //\n                //   VCHAR           =  %d33-126   ; visible (printing) characters\n                //   WSP             =  SP / HTAB  ; white space\n                //\n                //   obs-qp          =   \"\\\" (%d0 / obs-NO-WS-CTL / LF / CR)\n                //\n                //   obs-NO-WS-CTL   =   %d1-8 /   ; US-ASCII control\n                //                       %d11 /    ;  characters that do not\n                //                       %d12 /    ;  include the carriage\n                //                       %d14-31 / ;  return, line feed, and\n                //                       %d127     ;  white space characters\n                //\n                // i.e. obs-qp       =  \"\\\" (%d0-8, %d10-31 / %d127)\n                charCode = token.codePointAt(0);\n\n                if (charCode !== 127 &&  internals.c1Controls(charCode)) {\n                    // Fatal error\n                    updateResult(internals.diagnoses.errExpectingQPair);\n                }\n                else if ((charCode < 31 && charCode !== 9) || charCode === 127) {\n                    // ' ' and '\\t' are allowed\n                    updateResult(internals.diagnoses.deprecatedQP);\n                }\n\n                // At this point we know where this qpair occurred so we could check to see if the character actually needed to be quoted at all.\n                // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                //   the sending system SHOULD transmit the form that uses the minimum quoting possible.\n\n                context.prev = context.now;\n                // End of qpair\n                context.now = context.stack.pop();\n                const escapeToken = '\\\\' + token;\n\n                switch (context.now) {\n                    case internals.components.contextComment:\n                        break;\n\n                    case internals.components.contextQuotedString:\n                        parseData.local += escapeToken;\n                        atomData.locals[elementCount] += escapeToken;\n\n                        // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\n                        elementLength += 2;\n                        break;\n\n                    case internals.components.literal:\n                        parseData.domain += escapeToken;\n                        atomData.domains[elementCount] += escapeToken;\n\n                        // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\n                        elementLength += 2;\n                        break;\n\n                        // $lab:coverage:off$\n                    default:\n                        throw new Error('quoted pair logic invoked in an invalid context: ' + context.now);\n                        // $lab:coverage:on$\n                }\n\n                break;\n\n                // Comment\n            case internals.components.contextComment:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.2\n                //   comment  = \"(\" *([FWS] ccontent) [FWS] \")\"\n                //\n                //   ccontent = ctext / quoted-pair / comment\n                switch (token) {\n                    // Nested comment\n                    case '(':\n                        // Nested comments are ok\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextComment;\n                        break;\n\n                        // End of comment\n                    case ')':\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n                        break;\n\n                        // Quoted pair\n                    case '\\\\':\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextQuotedPair;\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        updateResult(internals.diagnoses.cfwsFWS);\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // CTEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\n                        //   ctext         = %d33-39 /  ; Printable US-ASCII\n                        //                   %d42-91 /  ;  characters not including\n                        //                   %d93-126 / ;  \"(\", \")\", or \"\\\"\n                        //                   obs-ctext\n                        //\n                        //   obs-ctext     = obs-NO-WS-CTL\n                        //\n                        //   obs-NO-WS-CTL = %d1-8 /    ; US-ASCII control\n                        //                   %d11 /     ;  characters that do not\n                        //                   %d12 /     ;  include the carriage\n                        //                   %d14-31 /  ;  return, line feed, and\n                        //                   %d127      ;  white space characters\n                        charCode = token.codePointAt(0);\n\n                        if (charCode === 0 || charCode === 10 || (charCode !== 127 && internals.c1Controls(charCode))) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingCTEXT);\n                            break;\n                        }\n                        else if (internals.c0Controls(charCode) || charCode === 127) {\n                            updateResult(internals.diagnoses.deprecatedCTEXT);\n                        }\n                }\n\n                break;\n\n                // Folding white space\n            case internals.components.contextFWS:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.2\n                //   FWS     =   ([*WSP CRLF] 1*WSP) /  obs-FWS\n                //                                   ; Folding white space\n\n                // But note the erratum:\n                // http://www.rfc-editor.org/errata_search.php?rfc=5322&eid=1908:\n                //   In the obsolete syntax, any amount of folding white space MAY be\n                //   inserted where the obs-FWS rule is allowed.  This creates the\n                //   possibility of having two consecutive \"folds\" in a line, and\n                //   therefore the possibility that a line which makes up a folded header\n                //   field could be composed entirely of white space.\n                //\n                //   obs-FWS =   1*([CRLF] WSP)\n\n                if (prevToken === '\\r') {\n                    if (token === '\\r') {\n                        // Fatal error\n                        updateResult(internals.diagnoses.errFWSCRLFx2);\n                        break;\n                    }\n\n                    if (++crlfCount > 1) {\n                        // Multiple folds => obsolete FWS\n                        updateResult(internals.diagnoses.deprecatedFWS);\n                    }\n                    else {\n                        crlfCount = 1;\n                    }\n                }\n\n                switch (token) {\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                        }\n\n                        break;\n\n                    case ' ':\n                    case '\\t':\n                        break;\n\n                    default:\n                        if (prevToken === '\\r') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errFWSCRLFEnd);\n                        }\n\n                        crlfCount = 0;\n\n                        // End of FWS\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n\n                        // Look at this token again in the parent context\n                        --i;\n                }\n\n                prevToken = token;\n                break;\n\n                // Unexpected context\n                // $lab:coverage:off$\n            default:\n                throw new Error('unknown context: ' + context.now);\n                // $lab:coverage:on$\n        } // Primary state machine\n\n        if (maxResult > internals.categories.rfc5322) {\n            // Fatal error, no point continuing\n            break;\n        }\n    } // Token loop\n\n    // Check for errors\n    if (maxResult < internals.categories.rfc5322) {\n        const punycodeLength = Punycode.toASCII(parseData.domain).length;\n        // Fatal errors\n        if (context.now === internals.components.contextQuotedString) {\n            updateResult(internals.diagnoses.errUnclosedQuotedString);\n        }\n        else if (context.now === internals.components.contextQuotedPair) {\n            updateResult(internals.diagnoses.errBackslashEnd);\n        }\n        else if (context.now === internals.components.contextComment) {\n            updateResult(internals.diagnoses.errUnclosedComment);\n        }\n        else if (context.now === internals.components.literal) {\n            updateResult(internals.diagnoses.errUnclosedDomainLiteral);\n        }\n        else if (token === '\\r') {\n            updateResult(internals.diagnoses.errFWSCRLFEnd);\n        }\n        else if (parseData.domain.length === 0) {\n            updateResult(internals.diagnoses.errNoDomain);\n        }\n        else if (elementLength === 0) {\n            updateResult(internals.diagnoses.errDotEnd);\n        }\n        else if (hyphenFlag) {\n            updateResult(internals.diagnoses.errDomainHyphenEnd);\n        }\n\n        // Other errors\n        else if (punycodeLength > 255) {\n            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.2\n            //   The maximum total length of a domain name or number is 255 octets.\n            updateResult(internals.diagnoses.rfc5322DomainTooLong);\n        }\n        else if (Buffer.byteLength(parseData.local, 'utf8') + punycodeLength + /* '@' */ 1 > 254) {\n            // http://tools.ietf.org/html/rfc5321#section-4.1.2\n            //   Forward-path   = Path\n            //\n            //   Path           = \"<\" [ A-d-l \":\" ] Mailbox \">\"\n            //\n            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3\n            //   The maximum total length of a reverse-path or forward-path is 256 octets (including the punctuation and element separators).\n            //\n            // Thus, even without (obsolete) routing information, the Mailbox can only be 254 characters long. This is confirmed by this verified\n            // erratum to RFC 3696:\n            //\n            // http://www.rfc-editor.org/errata_search.php?rfc=3696&eid=1690\n            //   However, there is a restriction in RFC 2821 on the length of an address in MAIL and RCPT commands of 254 characters.  Since\n            //   addresses that do not fit in those fields are not normally useful, the upper limit on address lengths should normally be considered\n            //   to be 254.\n            updateResult(internals.diagnoses.rfc5322TooLong);\n        }\n        else if (elementLength > 63) {\n            // http://tools.ietf.org/html/rfc1035#section-2.3.4\n            // labels   63 octets or less\n            updateResult(internals.diagnoses.rfc5322LabelTooLong);\n        }\n        else if (options.minDomainAtoms && atomData.domains.length < options.minDomainAtoms && (atomData.domains.length !== 1 || atomData.domains[0][0] !== '[')) {\n            updateResult(internals.diagnoses.errDomainTooShort);\n        }\n        else if (internals.hasDomainLiteralThenAtom(atomData.domains)) {\n            updateResult(internals.diagnoses.errDotAfterDomainLiteral);\n        }\n        else if (options.tldWhitelist || options.tldBlacklist) {\n            const tldAtom = atomData.domains[elementCount];\n\n            if (!internals.validDomain(tldAtom, options)) {\n                updateResult(internals.diagnoses.errUnknownTLD);\n            }\n        }\n    } // Check for errors\n\n    // Finish\n    if (maxResult < internals.categories.dnsWarn) {\n        // Per RFC 5321, domain atoms are limited to letter-digit-hyphen, so we only need to check code <= 57 to check for a digit\n        const code = atomData.domains[elementCount].codePointAt(0);\n\n        if (code <= 57) {\n            updateResult(internals.diagnoses.rfc5321TLDNumeric);\n        }\n    }\n\n    if (maxResult < threshold) {\n        maxResult = internals.diagnoses.valid;\n    }\n\n    const finishResult = diagnose ? maxResult : maxResult < internals.defaultThreshold;\n\n    // $lab:coverage:off$\n    if (callback) {\n        callback(finishResult);\n    }\n    // $lab:coverage:on$\n\n    return finishResult;\n};\n\n\nexports.diagnoses = internals.validate.diagnoses = (function () {\n\n    const diag = {};\n    const keys = Object.keys(internals.diagnoses);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        diag[key] = internals.diagnoses[key];\n    }\n\n    return diag;\n})();\n\n\nexports.normalize = internals.normalize;\n"]},"metadata":{},"sourceType":"script"}